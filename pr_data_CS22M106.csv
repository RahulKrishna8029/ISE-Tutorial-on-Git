,Pull Request Number,Pull Request State,Pull Request Body,Number of files changed,File Names,Number of Commits,Commit Messages,Commits Data,Review Comments
1,68,open,"This is a javascript implementation of the Bidirectional Conditional Insertion Sort algorithm published by Future Computer Systems Volume 71, June 2017, Pages 102-112. Read about it here: 
https://www.sciencedirect.com/science/article/pii/S0167739X17301711?via%3Dihub",6,"['README.md', 'package-lock.json', 'src/algorithms/sorting/SortTester.js', 'src/algorithms/sorting/bidirectional-conditional-insertion-sort/BCIS.js', 'src/algorithms/sorting/bidirectional-conditional-insertion-sort/README.md', 'src/algorithms/sorting/bidirectional-conditional-insertion-sort/__test__/BCISort.test.js']",13,"['added Bidirectional Conditional Insertion Sort', ""Merge branch 'master' into master"", 'cleaned up with eslint', ""Merge branch 'master' into master"", 'Passing eslist && npm test.', ""Merge branch 'master' of https://github.com/christian4423/javascript-algorithms"", 'improved tests', 'Working on getting tests to 100%', 'forgot to remove function', 'made large arrays break', ""Merge branch 'master' into master"", ""Merge branch 'master' into master"", ""Merge branch 'master' into master""]","{'Name': 'src/algorithms/sorting/bidirectional-conditional-insertion-sort/__test__/BCISort.test.js', 'Line Additions': 80, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,80 @@\n+import BCIS from '../BCIS';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  largeArr,\n+  mostlySortedlargeArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+const SORTED_ARRAY_VISITING_COUNT = 26;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 20;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 26;\n+const EQUAL_ARRAY_VISITING_COUNT = 90;\n+const LARGE_ARRAY_VISITING_COUNT = 705;\n+const MOSTLY_LARGE_ARRAY_VISITING_COUNT = 293;\n+\n+describe('BCIS', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(BCIS);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(BCIS);\n+  });\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+  it('should visit NOT SORTED LARGE array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      largeArr,\n+      LARGE_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+  it('should visit MOSTLY SORTED LARGE array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BCIS,\n+      mostlySortedlargeArr,\n+      MOSTLY_LARGE_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+  it('An Array object is required', () => {\n+    SortTester.testAlgorithmTimeWithoutArray(\n+      BCIS,\n+      null,\n+      0,\n+    );\n+  });\n+});""}",[]
2,128,open,,3,"['src/data-structures/linked-list/LinkedList.js', 'src/data-structures/linked-list/__test__/LinkedList.test.js', 'src/data-structures/queue/Queue.js']",15,"[""Added new function and test\n\nAdded function  'addToPosition' which add new node to specified position in the list."", 'Minor bugs', 'Minor bugs\n\nMinor bugs about tabs and spaces.', ""Minor bugs\n\n  199:17  error  A space is required after '{'                 object-curly-spacing\n  199:57  error  A space is required before '}'                object-curly-spacing\n  201:1   error  Expected indentation of 6 spaces but found 8  indent\n  218:13  error  Infix operators must be spaced                space-infix-ops\n  225:7   error  Unary operator '++' used                      no-plusplus"", 'Spaces', 'spaces', 'New version of queue\n\nInside linked list is protected from user.\nIn previous version for example I was able to add node to list.head', 'Bugs\n\n5:23  error    Move the invocation into the parens that contain the function  wrap-iife\n   5:24  warning  Unexpected unnamed function                                    func-names\n   5:32  error    Missing space before function parentheses                      space-before-function-paren\n   6:11  error    \'temp\' is never reassigned. Use \'const\' instead                prefer-const\n   6:19  error    Multiple spaces found before \'new\'                             no-multi-spaces\n   9:9   error    Expected method shorthand                                      object-shorthand\n   9:18  warning  Unexpected unnamed method \'isEmpty\'                            func-names\n   9:26  error    Missing space before function parentheses                      space-before-function-paren\n  12:9   error    Expected method shorthand                                      object-shorthand\n  12:15  warning  Unexpected unnamed method \'peek\'                               func-names\n  12:23  error    Missing space before function parentheses                      space-before-function-paren\n  13:11  error    Expected space(s) after ""if""                                   keyword-spacing\n  20:9   error39m    Expected method shorthand                                      object-shorthand\n  20:18  warning  Unexpected unnamed method \'enqueue\'                            func-names\n  20:26  error    Missing space before function parentheses                      space-before-function-paren\n  24:9   error    Expected method shorthand                                      object-shorthand\n  24:18  warning  Unexpected unnamed method \'dequeue\'                            func-names\n  24:26  error    Missing space before function parentheses                      space-before-function-paren\n  29:9   error    Expected method shorthand                                      object-shorthand\n  29:19  warning  Unexpected unnamed method \'toString\'                           func-names\n  29:27  error    Missing space before function parentheses                      space-before-function-paren\n  31:10  error    Missing trailing comma                                         comma-dangle', 'Bugs\n\n5:23  error    Move the invocation into the parens that contain the function  wrap-iife\n   5:24  warning  Unexpected unnamed function                                    func-names\n  14:11  error    Expected space(s) after ""if""                                   keyword-spacing\n  32:10  error    Missing trailing comma                                         comma-dangle\n  34:5   error    Unexpected space between function name and paren               func-call-spacing\n  34:5   error    Unexpected space between function name and paren               no-spaced-func', 'Minor spaces bugs\n\n5:23  error  There should be no spaces inside this paren  space-in-parens\n  34:7   error  There should be no spaces inside this paren  space-in-parens', ""Merge branch 'master' into master"", 'Stack is more simplier\n\nStack is now more simplier to understand and without any redundant functionality from linked list class', 'Revert ""Stack is more simplier""\n\nThis reverts commit 0032e94cf1fa8c47361ab6ef15744101ee9b8593.', ""Merge branch 'master' into master"", ""Merge branch 'master' into master""]","{'Name': 'src/data-structures/queue/Queue.js', 'Line Additions': 34, 'Line Deletions': 10, 'Patch': ""@@ -2,28 +2,52 @@ import LinkedList from '../linked-list/LinkedList';\n \n export default class Queue {\n   constructor() {\n-    this.linkedList = new LinkedList();\n+    this.linkedList = (() => {\n+      const temp = new LinkedList();\n+\n+      return {\n+        isEmpty: () => {\n+          return !temp.tail;\n+        },\n+\n+        peek: () => {\n+          if (!temp.head) {\n+            return null;\n+          }\n+\n+          return temp.head.value;\n+        },\n+\n+        enqueue: (value) => {\n+          temp.append(value);\n+        },\n+\n+        dequeue: () => {\n+          const removedHead = temp.deleteHead();\n+          return removedHead ? removedHead.value : null;\n+        },\n+\n+        toString: (callback) => {\n+          return temp.toString(callback);\n+        },\n+      };\n+    })();\n   }\n \n   isEmpty() {\n-    return !this.linkedList.tail;\n+    return this.linkedList.isEmpty();\n   }\n \n   peek() {\n-    if (!this.linkedList.head) {\n-      return null;\n-    }\n-\n-    return this.linkedList.head.value;\n+    return this.linkedList.peek();\n   }\n \n   enqueue(value) {\n-    this.linkedList.append(value);\n+    return this.linkedList.enqueue(value);\n   }\n \n   dequeue() {\n-    const removedHead = this.linkedList.deleteHead();\n-    return removedHead ? removedHead.value : null;\n+    return this.linkedList.dequeue();\n   }\n \n   toString(callback) {""}",[]
3,139,open,Function to extract 'k' bits from position 'p' and returns the extracted value as integer.,1,['src/algorithms/math/bits/extractBits.js'],3,"[""Create extractBits.js\n\nFunction to extract 'k' bits from position 'p' and returns the extracted value as integer."", 'Update extractBits.js', 'Update extractBits.js']","{'Name': 'src/algorithms/math/bits/extractBits.js', 'Line Additions': 13, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,13 @@\n+/**\n+ * @param {number, number, number}\n+ * @return {number}\n+ */\n+ \n+ \n+ /*  Function to extract 'k' bits from position 'p'\n+  *  and returns the extracted value.\n+  *\n+  */\n+export default function extractBits(number, k, p) {\n+    return (((1 << k) - 1) & (number >> (p - 1)));\n+}""}",[]
4,149,open,Used library functions on arrays instead of loops.,1,['src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js'],1,['Make Rain Terraces more terse using standard array functions'],"{'Name': 'src/algorithms/uncategorized/rain-terraces/dpRainTerraces.js', 'Line Additions': 6, 'Line Deletions': 38, 'Patch': ""@@ -5,43 +5,11 @@\n  * @return {number}\n  */\n export default function dpRainTerraces(terraces) {\n-  let waterAmount = 0;\n+  // Obtain the maximum elevations to the left and right of each terrace (inclusive).\n+  const maxL = terraces.reduce((acc, val, idx) => [...acc, Math.max(val, (acc[idx - 1] || 0))], []);\n+  const maxR = terraces.reduceRight((acc, val) => [Math.max(val, (acc[0] || 0)), ...acc], []);\n \n-  // Init arrays that will keep the list of left and right maximum levels for specific positions.\n-  const leftMaxLevels = new Array(terraces.length).fill(0);\n-  const rightMaxLevels = new Array(terraces.length).fill(0);\n-\n-  // Calculate the highest terrace level from the LEFT relative to the current terrace.\n-  [leftMaxLevels[0]] = terraces;\n-  for (let terraceIndex = 1; terraceIndex < terraces.length; terraceIndex += 1) {\n-    leftMaxLevels[terraceIndex] = Math.max(\n-      terraces[terraceIndex],\n-      leftMaxLevels[terraceIndex - 1],\n-    );\n-  }\n-\n-  // Calculate the highest terrace level from the RIGHT relative to the current terrace.\n-  rightMaxLevels[terraces.length - 1] = terraces[terraces.length - 1];\n-  for (let terraceIndex = terraces.length - 2; terraceIndex >= 0; terraceIndex -= 1) {\n-    rightMaxLevels[terraceIndex] = Math.max(\n-      terraces[terraceIndex],\n-      rightMaxLevels[terraceIndex + 1],\n-    );\n-  }\n-\n-  // Not let's go through all terraces one by one and calculate how much water\n-  // each terrace may accumulate based on previously calculated values.\n-  for (let terraceIndex = 0; terraceIndex < terraces.length; terraceIndex += 1) {\n-    // Pick the lowest from the left/right highest terraces.\n-    const currentTerraceBoundary = Math.min(\n-      leftMaxLevels[terraceIndex],\n-      rightMaxLevels[terraceIndex],\n-    );\n-\n-    if (currentTerraceBoundary > terraces[terraceIndex]) {\n-      waterAmount += currentTerraceBoundary - terraces[terraceIndex];\n-    }\n-  }\n-\n-  return waterAmount;\n+  // Convert maximum values to amount of water at current index and sum water values.\n+  const trap = terraces.map((val, idx) => Math.max(0, Math.min(maxL[idx], maxR[idx]) - val));\n+  return trap.reduce((acc, val) => acc + val);\n }""}",[]
5,150,open,Added implementation of efficient LIS (nlog(n) run time),2,"['src/algorithms/sets/longest-increasing-subsequence/__test__/longestIncreasingSubsequence.test.js', 'src/algorithms/sets/longest-increasing-subsequence/longestIncreasingSubsequence.js']",1,['Added Efficient LIS (nlog(n))'],"{'Name': 'src/algorithms/sets/longest-increasing-subsequence/longestIncreasingSubsequence.js', 'Line Additions': 28, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,28 @@\n+/**\n+ * Efficient approach to find longest increasing subsequence.\n+ * Complexity: O(n * log(n))\n+ *\n+ * @param {number[]} sequence\n+ * @return {number}\n+ */\n+export default function LongestIncreasingSubsequence(sequence) {\n+  // Retrieves the smallest number greater or equal to val in sorted arr.\n+  function upperBound(arr, val) {\n+    let lo = 0;\n+    let hi = arr.length;\n+\n+    while (lo < hi) {\n+      const mid = lo + Math.floor((hi - lo) / 2);\n+      if (arr[mid] < val) {\n+        lo = mid + 1;\n+      } else {\n+        hi = mid;\n+      }\n+    }\n+    return hi;\n+  }\n+\n+  const lis = [];\n+  sequence.forEach((val) => { lis[upperBound(lis, val)] = val; });\n+  return lis.length;\n+}'}",[]
6,160,open,Used standard javascript array functionality to condense implementation,1,['src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js'],1,['Made maximum subarray solution more terse'],"{'Name': 'src/algorithms/sets/maximum-subarray/dpMaximumSubarray.js', 'Line Additions': 9, 'Line Deletions': 52, 'Patch': ""@@ -1,62 +1,19 @@\n /**\n- * Dynamic Programming solution.\n+ * Dynamic Programming solution using Kadane's algorithm.\n  * Complexity: O(n)\n  *\n  * @param {Number[]} inputArray\n  * @return {Number[]}\n  */\n export default function dpMaximumSubarray(inputArray) {\n-  // Check if all elements of inputArray are negative ones and return the highest\n-  // one in this case.\n-  let allNegative = true;\n-  let highestElementValue = null;\n-  for (let i = 0; i < inputArray.length; i += 1) {\n-    if (inputArray[i] >= 0) {\n-      allNegative = false;\n-    }\n+  // Use Kadane's algorithm to generate list of maximum sums ending/beginning at index.\n+  const endMax = inputArray.reduce((a, x, i) => a.concat([x + Math.max(0, a[i - 1] || 0)]), []);\n+  const begMax = inputArray.reduceRight((a, x) => [x + Math.max(0, a[0] || 0)].concat(a), []);\n \n-    if (highestElementValue === null || highestElementValue < inputArray[i]) {\n-      highestElementValue = inputArray[i];\n-    }\n-  }\n+  // Obtain the maximum value for the sum of subarrays.\n+  const maxVal = begMax.reduce((acc, val) => Math.max(acc, val), -Infinity);\n \n-  if (allNegative && highestElementValue !== null) {\n-    return [highestElementValue];\n-  }\n-\n-  // Let's assume that there is at list one positive integer exists in array.\n-  // And thus the maximum sum will for sure be grater then 0. Thus we're able\n-  // to always reset max sum to zero.\n-  let maxSum = 0;\n-\n-  // This array will keep a combination that gave the highest sum.\n-  let maxSubArray = [];\n-\n-  // Current sum and subarray that will memoize all previous computations.\n-  let currentSum = 0;\n-  let currentSubArray = [];\n-\n-  for (let i = 0; i < inputArray.length; i += 1) {\n-    // Let's add current element value to the current sum.\n-    currentSum += inputArray[i];\n-\n-    if (currentSum < 0) {\n-      // If the sum went below zero then reset it and don't add current element to max subarray.\n-      currentSum = 0;\n-      // Reset current subarray.\n-      currentSubArray = [];\n-    } else {\n-      // If current sum stays positive then add current element to current sub array.\n-      currentSubArray.push(inputArray[i]);\n-\n-      if (currentSum > maxSum) {\n-        // If current sum became greater then max registered sum then update\n-        // max sum and max subarray.\n-        maxSum = currentSum;\n-        maxSubArray = currentSubArray.slice();\n-      }\n-    }\n-  }\n-\n-  return maxSubArray;\n+  // Extract indices of maximum value from array & use them to slice input.\n+  const maxCmp = val => (val === maxVal);\n+  return inputArray.slice(begMax.findIndex(maxCmp), endMax.findIndex(maxCmp) + 1);\n }""}",[]
7,171,open,"The method for choosing the pivot as implemented at the moment results in degenerate behaviour when the array is already sorted or reverse sorted. A better way is to choose the median of three elements (first, mid, last) as the pivot. See Robert Sedgewick. Implementing Quicksort Programs. Commun. ACM, 1(10):847–857, October 1978.",3,"['src/algorithms/graph/kruskal/kruskal.js', 'src/algorithms/sorting/quick-sort/QuickSort.js', 'src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js']",3,"['choose pivot from median of three elements for quicksort', ""Merge branch 'master' into master"", ""fix pivot picking and kruskal's algorithm""]","{'Name': 'src/algorithms/sorting/quick-sort/__test__/QuickSort.test.js', 'Line Additions': 4, 'Line Deletions': 4, 'Patch': ""@@ -8,10 +8,10 @@ import {\n } from '../../SortTester';\n \n // Complexity constants.\n-const SORTED_ARRAY_VISITING_COUNT = 190;\n-const NOT_SORTED_ARRAY_VISITING_COUNT = 62;\n-const REVERSE_SORTED_ARRAY_VISITING_COUNT = 190;\n-const EQUAL_ARRAY_VISITING_COUNT = 19;\n+const SORTED_ARRAY_VISITING_COUNT = 66;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 83;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 66;\n+const EQUAL_ARRAY_VISITING_COUNT = 20;\n \n describe('QuickSort', () => {\n   it('should sort array', () => {""}",[]
8,182,open,two strings are anagram or not,1,['src/algorithms/string/anagram.js'],5,"['Create anagram.js\n\ntwo strings are anagram or not', ""Merge branch 'master' into patch-1"", ""Merge branch 'master' into patch-1"", 'corrected the code and added indentation', 'Changed the identations']","{'Name': 'src/algorithms/string/anagram.js', 'Line Additions': 21, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,21 @@\n+// TO CHECK IF TWO STRINGS ARE ANAGRAM OR NOT\n+\n+function anagram(word1, word2) {\n+  let sorted1 = word1.split('').sort().join(''); //SORTING WORD1\n+  let sorted2 = word2.split('').sort().join(''); //SORTING WORD2\n+\n+  //COMPARING LENGTH AND CHECKING === \n+  if (sorted1.length === sorted2.length && sorted1 === sorted2) {\n+        return true;\n+  }\n+  else{\n+        return false;\n+  }\n+}\n+\n+if(anagram('binary', 'brainy')){\n+  alert('AN ANAGRAM');  \n+}\n+else{\n+  alert('NOT AN ANAGRAM');\n+}""}",[]
9,186,open,"This PR adds support for complex data to the PriorityQueue class.

**Changes:**
- uses native JS `Map` data structure to store priorities. This way, objects, functions, or primitives can be used as keys. A plain JS `Object` coerces keys to strings, so different objects could all have the same key of `[object Object]`
- allows constructing a new `PriorityQueue` with a custom `compareValue` function, so complex data can be compared

example usage:
```js
const JOB1 = { type: 'job1' };
const JOB2 = { type: 'job2' };
const JOB3 = { type: 'job3' };

const compareByType = (a, b) => {
  if (a.type === b.type) {
    return 0;
  }
  return a.type < b.type ? -1 : 1;
};

const priorityQueue = new PriorityQueue(compareByType);

priorityQueue.add(JOB2, 2);
priorityQueue.peek(); // returns JOB2 

priorityQueue.add(JOB3, 3);
priorityQueue.peek(); // returns JOB2 

priorityQueue.add(JOB1, 1);
priorityQueue.peek(); // returns JOB1

priorityQueue.changePriority(JOB2, 0);
priorityQueue.peek(); // returns JOB2 

const existingJobType = { type: 'job1' };
const newJobType = { type: 'job4' };

priorityQueue.hasValue(existingJobType); // returns true
priorityQueue.hasValue(newJobType); // returns false
```",3,"['src/data-structures/heap/Heap.js', 'src/data-structures/priority-queue/PriorityQueue.js', 'src/data-structures/priority-queue/__test__/PriorityQueue.test.js']",3,"['Add support for complex data to PriorityQueue', 'add ability to change priority for a group of elements', 'use JSDoc optional parameter syntax']","{'Name': 'src/data-structures/priority-queue/__test__/PriorityQueue.test.js', 'Line Additions': 112, 'Line Deletions': 53, 'Patch': ""@@ -1,5 +1,11 @@\n import PriorityQueue from '../PriorityQueue';\n \n+const JOB1 = { type: 'job1' };\n+const JOB2 = { type: 'job2' };\n+const JOB3 = { type: 'job3' };\n+const JOB4 = { type: 'job4' };\n+const JOB5 = { type: 'job5' };\n+\n describe('PriorityQueue', () => {\n   it('should create default priority queue', () => {\n     const priorityQueue = new PriorityQueue();\n@@ -10,94 +16,147 @@ describe('PriorityQueue', () => {\n   it('should insert items to the queue and respect priorities', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    expect(priorityQueue.peek()).toBe(10);\n+    priorityQueue.add(JOB1, 1);\n+    expect(priorityQueue.peek()).toBe(JOB1);\n \n-    priorityQueue.add(5, 2);\n-    expect(priorityQueue.peek()).toBe(10);\n+    priorityQueue.add(JOB2, 2);\n+    expect(priorityQueue.peek()).toBe(JOB1);\n \n-    priorityQueue.add(100, 0);\n-    expect(priorityQueue.peek()).toBe(100);\n+    priorityQueue.add(JOB3, 0);\n+    expect(priorityQueue.peek()).toBe(JOB3);\n   });\n \n   it('should poll from queue with respect to priorities', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    priorityQueue.add(5, 2);\n-    priorityQueue.add(100, 0);\n-    priorityQueue.add(200, 0);\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+    priorityQueue.add(JOB4, 0);\n \n-    expect(priorityQueue.poll()).toBe(100);\n-    expect(priorityQueue.poll()).toBe(200);\n-    expect(priorityQueue.poll()).toBe(10);\n-    expect(priorityQueue.poll()).toBe(5);\n+    expect(priorityQueue.poll()).toBe(JOB3);\n+    expect(priorityQueue.poll()).toBe(JOB4);\n+    expect(priorityQueue.poll()).toBe(JOB1);\n+    expect(priorityQueue.poll()).toBe(JOB2);\n   });\n \n   it('should be possible to change priority of internal nodes', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    priorityQueue.add(5, 2);\n-    priorityQueue.add(100, 0);\n-    priorityQueue.add(200, 0);\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+    priorityQueue.add(JOB4, 0);\n \n-    priorityQueue.changePriority(100, 10);\n-    priorityQueue.changePriority(10, 20);\n+    priorityQueue.changePriority(JOB4, 10);\n+    priorityQueue.changePriority(JOB1, 20);\n \n-    expect(priorityQueue.poll()).toBe(200);\n-    expect(priorityQueue.poll()).toBe(5);\n-    expect(priorityQueue.poll()).toBe(100);\n-    expect(priorityQueue.poll()).toBe(10);\n+    expect(priorityQueue.poll()).toBe(JOB3);\n+    expect(priorityQueue.poll()).toBe(JOB2);\n+    expect(priorityQueue.poll()).toBe(JOB4);\n+    expect(priorityQueue.poll()).toBe(JOB1);\n   });\n \n   it('should be possible to change priority of head node', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    priorityQueue.add(5, 2);\n-    priorityQueue.add(100, 0);\n-    priorityQueue.add(200, 0);\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+    priorityQueue.add(JOB4, 0);\n \n-    priorityQueue.changePriority(200, 10);\n-    priorityQueue.changePriority(10, 20);\n+    priorityQueue.changePriority(JOB3, 10);\n+    priorityQueue.changePriority(JOB1, 20);\n \n-    expect(priorityQueue.poll()).toBe(100);\n-    expect(priorityQueue.poll()).toBe(5);\n-    expect(priorityQueue.poll()).toBe(200);\n-    expect(priorityQueue.poll()).toBe(10);\n+    expect(priorityQueue.poll()).toBe(JOB4);\n+    expect(priorityQueue.poll()).toBe(JOB2);\n+    expect(priorityQueue.poll()).toBe(JOB3);\n+    expect(priorityQueue.poll()).toBe(JOB1);\n   });\n \n   it('should be possible to change priority along with node addition', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    priorityQueue.add(5, 2);\n-    priorityQueue.add(100, 0);\n-    priorityQueue.add(200, 0);\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+    priorityQueue.add(JOB4, 0);\n \n-    priorityQueue.changePriority(200, 10);\n-    priorityQueue.changePriority(10, 20);\n+    priorityQueue.changePriority(JOB4, 10);\n+    priorityQueue.changePriority(JOB1, 20);\n \n-    priorityQueue.add(15, 15);\n+    priorityQueue.add(JOB5, 15);\n \n-    expect(priorityQueue.poll()).toBe(100);\n-    expect(priorityQueue.poll()).toBe(5);\n-    expect(priorityQueue.poll()).toBe(200);\n-    expect(priorityQueue.poll()).toBe(15);\n-    expect(priorityQueue.poll()).toBe(10);\n+    expect(priorityQueue.poll()).toBe(JOB3);\n+    expect(priorityQueue.poll()).toBe(JOB2);\n+    expect(priorityQueue.poll()).toBe(JOB4);\n+    expect(priorityQueue.poll()).toBe(JOB5);\n+    expect(priorityQueue.poll()).toBe(JOB1);\n+  });\n+\n+  it('should be possible to change the priority of a group of elements', () => {\n+    const A = 'a';\n+    const B = 'b';\n+    const jobA1 = { type: A, id: 1 };\n+    const jobB1 = { type: B, id: 2 };\n+    const jobB2 = { type: B, id: 3 };\n+\n+    const priorityQueue = new PriorityQueue();\n+\n+    priorityQueue.add(jobA1, 2);\n+    priorityQueue.add(jobB1, 8);\n+    priorityQueue.add(jobB2, 9);\n+\n+    expect(priorityQueue.peek()).toBe(jobA1);\n+\n+    const compareByType = (a, b) => {\n+      if (a.type === b.type) {\n+        return 0;\n+      }\n+\n+      return a.type < b.type ? -1 : 1;\n+    };\n+\n+    priorityQueue.changePriority({ type: B }, 1, compareByType);\n+\n+    expect(priorityQueue.poll().type).toBe(B);\n+    expect(priorityQueue.poll().type).toBe(B);\n   });\n \n   it('should be possible to search in priority queue by value', () => {\n     const priorityQueue = new PriorityQueue();\n \n-    priorityQueue.add(10, 1);\n-    priorityQueue.add(5, 2);\n-    priorityQueue.add(100, 0);\n-    priorityQueue.add(200, 0);\n-    priorityQueue.add(15, 15);\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+    priorityQueue.add(JOB4, 0);\n+    priorityQueue.add(JOB5, 15);\n+\n+    const job6 = { type: 'job6' };\n+\n+    expect(priorityQueue.hasValue(job6)).toBe(false);\n+    expect(priorityQueue.hasValue(JOB5)).toBe(true);\n+  });\n+\n+  it('should accept a custom compareValue function', () => {\n+    const compareByType = (a, b) => {\n+      if (a.type === b.type) {\n+        return 0;\n+      }\n+\n+      return a.type < b.type ? -1 : 1;\n+    };\n+\n+    const priorityQueue = new PriorityQueue(compareByType);\n+\n+    priorityQueue.add(JOB1, 1);\n+    priorityQueue.add(JOB2, 2);\n+    priorityQueue.add(JOB3, 0);\n+\n+    const existingJobType = { type: 'job1' };\n+    const newJobType = { type: 'job4' };\n \n-    expect(priorityQueue.hasValue(70)).toBe(false);\n-    expect(priorityQueue.hasValue(15)).toBe(true);\n+    expect(priorityQueue.hasValue(existingJobType)).toBe(true);\n+    expect(priorityQueue.hasValue(newJobType)).toBe(false);\n   });\n });""}",[]
10,199,open,"Functions added:
- fastExponent(base, exponent) 
- modularExponent(base, exponent, m)

Files added:
- Algorithm Readme

Files updated:
- Root Readme

",7,"['README.md', 'package-lock.json', 'src/algorithms/math/fast-exponentiation/README.md', 'src/algorithms/math/fast-exponentiation/__test__/fastExponent.test.js', 'src/algorithms/math/fast-exponentiation/__test__/modularExponent.test.js', 'src/algorithms/math/fast-exponentiation/fastExponent.js', 'src/algorithms/math/fast-exponentiation/modularExponent.js']",2,"['Added fast-exponentiation algorithm', ""Merge branch 'master' into master""]","{'Name': 'src/algorithms/math/fast-exponentiation/modularExponent.js', 'Line Additions': 23, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,23 @@\n+/**\n+ * @param {number} base\n+ * @param {number} exponent\n+ * @param {number} m\n+ * @return {number}\n+ */\n+\n+export default function modularExponent(base, exponent, m) {\n+  let x = base;\n+  let y = exponent;\n+  let res = 1;\n+  const p = m;\n+\n+  x %= p;\n+\n+  while (y > 0) {\n+    if (y & 1) res = (res * x) % p;\n+    y >>= 1;\n+    x = (x * x) % p;\n+  }\n+\n+  return res;\n+}'}",[]
11,200,open,,10,"['README.md', 'src/algorithms/math/bits/__test__/isEven.test.js', 'src/algorithms/math/bits/countSetBits.js', 'src/algorithms/math/bits/isEven.js', 'src/algorithms/math/extended-euclidean-algorithm/README.MD', 'src/algorithms/math/extended-euclidean-algorithm/__test__/extendedEuclid.test.js', 'src/algorithms/math/extended-euclidean-algorithm/extendedEuclid.js', 'src/algorithms/math/nth-root/README.MD', 'src/algorithms/math/nth-root/__test__/nthRoot.test.js', 'src/algorithms/math/nth-root/nthRoot.js']",8,"['Improved the countSetBit', 'Added if number is Even or Odd', 'Added if number is Even or Odd', 'Added nth root of number', 'counting set bit Optimized', 'Updated few Files', 'Added Extended Euclidean Algorithm', 'Update README.md']","{'Name': 'src/algorithms/math/nth-root/nthRoot.js', 'Line Additions': 32, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,32 @@\n+/**\n+ * @param {number} num\n+ * @param {number} power\n+ * @return {number}\n+ */\n+\n+export default function nthRoot(num, power) {\n+  const E = 0.000000001;\n+  const roundToMargin = (x) => {\n+    return Math.round(x / E) * E;\n+  };\n+\n+  let guess;\n+  const calculateError = () => Math.abs(num - (guess ** power));\n+\n+  let start = 0;\n+  let end = num;\n+  let error = 1;\n+\n+  while (error > E) {\n+    guess = (start + end) / 2;\n+    error = calculateError();\n+\n+    if (guess ** power > num) {\n+      end = guess;\n+    } else {\n+      start = guess;\n+    }\n+  }\n+\n+  return roundToMargin(guess);\n+}'}",[]
12,209,open,This algorithm works in O(logn) time and much more powerful than the above algorithms,1,['src/algorithms/math/fibonacci/Q_matrix.js'],1,['Create Q_matrix.js\n\nThis algorithm works in O(logn) time and much more powerful than the above algorithms'],"{'Name': 'src/algorithms/math/fibonacci/Q_matrix.js', 'Line Additions': 43, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,43 @@\n+/**\n+ * Calculate fibonacci number at specific position using Q matrix in O(logn) time.\n+ *\n+ * @param n\n+ * @return {number}\n+ */\n+ export default function fibonacciNth(n) {\n+ \n+  //Require math.js library. If you're from python background, it is equivalent to numpy\n+  const math = require('mathjs');\n+  \n+  //mod is just for our convenience to see how quick large values are getting computed\n+  const M = math.matrix([[1,1],[1,0]]),\n+        Q = M,\n+        mod = 10 ** 9 + 7;\n+\n+  //Using Q^n = Q^n/2 * Q^n/2\n+  const power = (Q,n) => {\n+    if(n == 1){\n+        return M;\n+    }\n+\n+    Q = power(Q,Math.floor(n/2));\n+    Q = math.mod(math.multiply(Q,Q),mod);\n+    if(n % 2 != 0){\n+        Q = math.mod(math.multiply(Q,M),mod);\n+    }\n+\n+    return Q;\n+\n+}\n+  \n+  const fibonacci = (Q,n) => {\n+      //Q^n = [[Fn+1, Fn], [Fn, Fn-1]]\n+      Q = power(Q,n-1);\n+      \n+      //Q:{ _data:[[],[]], _size:[m, n], _datatype: string | number}\n+      return Q['_data'][0][0];\n+  }\n+  \n+  return fibonacci(Q,n)\n+\n+}""}",[]
13,210,open,,3,"['src/algorithms/string/palindrome/README.md', 'src/algorithms/string/palindrome/__true__/palindrome.test.js', 'src/algorithms/string/palindrome/palindrome.js']",7,"['Check for palindromes', 'Add test for palindrome()', 'Add README', 'Fix errors', 'Fix one more error', 'Fix error', ""Merge branch 'master' into ocnly-palindrome""]","{'Name': 'src/algorithms/string/palindrome/palindrome.js', 'Line Additions': 8, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,8 @@\n+/**\n+ * @param {string} string\n+ * @return {boolean}\n+ */\n+export default function palindrome(string) {\n+  const reverseString = string.split('').reverse().join('');\n+  return reverseString === string;\n+}""}",[]
14,215,open,"Hello,

Iterative quick sort is a popular interview question, so i think it would be nice to have it here.

",2,"['src/algorithms/sorting/quick-sort/QuickSortIterative.js', 'src/algorithms/sorting/quick-sort/__test__/QuickSortIterative.test.js']",1,['Add iterative quick sort'],"{'Name': 'src/algorithms/sorting/quick-sort/__test__/QuickSortIterative.test.js', 'Line Additions': 74, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,74 @@\n+import QuickSortIterative from '../QuickSortIterative';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+const SORTED_ARRAY_VISITING_COUNT = 19;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 19;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 19;\n+const EQUAL_ARRAY_VISITING_COUNT = 19;\n+\n+describe('QuickSortIterative', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(QuickSortIterative);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(QuickSortIterative);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(QuickSortIterative);\n+  });\n+\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortIterative,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortIterative,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortIterative,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortIterative,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should sort in place', () => {\n+    const sorter = new QuickSortIterative();\n+    const originalArray = [7, 5, 1, 42, 30, 24, 14];\n+    const sortedArray = sorter.sort(originalArray);\n+    expect(originalArray).toEqual(sortedArray);\n+  });\n+\n+  it('should not modify original array', () => {\n+    const sorter = new QuickSortIterative();\n+    const originalArray = [7, 5, 1, 42, 30, 24, 14];\n+    const sortedArray = sorter.sort(originalArray, 0, originalArray.length - 1, false);\n+    expect(originalArray).not.toEqual(sortedArray);\n+  });\n+});""}","['Nice addition! Just to nitpick, it might be a little cleaner to store arrays on the stack. That way, each item in the stack corresponds to a single iteration.\r\ne.g.\r\n```js\r\n    let lowIndex = inputLowIndex;\r\n    let highIndex = inputHighIndex;\r\n    let partitionIndex;\r\n    \r\n    stack.push([ lowIndex, highIndex ]);\r\n\r\n    while (!stack.isEmpty()) {\r\n      [ lowIndex, highIndex ] = stack.pop();\r\n      partitionIndex = partitionArray(lowIndex, highIndex);\r\n      if (partitionIndex - 1 > lowIndex) {\r\n        stack.push([ lowIndex, partitionIndex - 1 ]);\r\n      }\r\n      if (partitionIndex + 1 < highIndex) {\r\n        stack.push([ partitionIndex + 1, highIndex ]);\r\n      }\r\n    }\r\n```']"
15,219,open,This adds Linear prime sieve,3,"['src/algorithms/math/linear-prime-sieve/README.md', 'src/algorithms/math/linear-prime-sieve/__test__/linearPrimeSieve.test.js', 'src/algorithms/math/linear-prime-sieve/linearPrimeSieve.js']",8,"['Add linear prime sieve', 'Adds README.md', 'Adds linearPrimeSieve tests', 'Refactor linearPrimeSieve.js', 'refactor linearPrimSieve.test.js as per eslint', ""Merge branch 'master' of https://github.com/trekhleb/javascript-algorithms into linear-prime-sieve"", ""Merge branch 'master' into linear-prime-sieve"", ""Merge branch 'master' into linear-prime-sieve""]","{'Name': 'src/algorithms/math/linear-prime-sieve/linearPrimeSieve.js', 'Line Additions': 35, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,35 @@\n+/**\n+ * @param {number} maxNumber\n+ * @return {number[]}\n+ */\n+export default function linearPrimeSieve(maxNumber) {\n+  const primes = [];\n+  // leastPrimeFactor[i] gives us the least prime factor of 'i'\n+  const leastPrimeFactor = new Array(maxNumber + 1).fill(0);\n+\n+  for (let i = 2; i <= maxNumber; i += 1) {\n+    if (!leastPrimeFactor[i]) {\n+      /* leastPrimeFactor[i] = 0 means 'i' itself is its least prime factor,\n+       * i.e 'i' is prime\n+       */\n+      leastPrimeFactor[i] = i;\n+      primes.push(i);\n+    }\n+\n+    /*\n+     *  start setting leastPrimeFactor[] for numbers 'x', where x = p * i, p is x's\n+     *  least prime factor and p <= leastPrimeFactor[i]. x = p*i, this representation will\n+     *  be unique for any number, therefore leastPrimeFactor[x] will be\n+     *  set only once.\n+     */\n+\n+    let j = 0;\n+    while (j < primes.length) {\n+      if ((primes[j] * i > maxNumber) || (primes[j] > leastPrimeFactor[i])) { break; }\n+      leastPrimeFactor[primes[j] * i] = primes[j];\n+      j += 1;\n+    }\n+  }\n+\n+  return primes;\n+}""}",[]
16,223,open,"This PR add an non-recursive implementation for Segment Tree with methods for:

- Query on range
- Update single element

Also it updates: Root, Spanish and Portuguese readmes.",6,"['README.es-ES.md', 'README.md', 'README.pt-BR.md', 'src/data-structures/tree/non-recursive-segment-tree/NonRecursiveSegmentTree.js', 'src/data-structures/tree/non-recursive-segment-tree/README.md', 'src/data-structures/tree/non-recursive-segment-tree/__test__/NonRecursiveSegmentTree.test.js']",15,"['non-recursive segment tree implementation', ""Merge branch 'master' into iterative-segment-tree\n\n# Conflicts:\n#\tREADME.es-ES.md"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", ""Merge branch 'master' into iterative-segment-tree"", 'Fix README.pt-BR.md conflict.', ""Merge branch 'master' into iterative-segment-tree""]","{'Name': 'src/data-structures/tree/non-recursive-segment-tree/__test__/NonRecursiveSegmentTree.test.js', 'Line Additions': 163, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,163 @@\n+import NonRecursiveSegmentTree from '../NonRecursiveSegmentTree';\n+\n+describe('IterativeSegmentTree', () => {\n+  it('should build tree for input array #0 with length of power of two', () => {\n+    const array = [-1, 2];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, -1, -1, 2]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build tree for input array #1 with length of power of two', () => {\n+    const array = [-1, 2, 4, 0];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, -1, -1, 0, -1, 2, 4, 0]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build tree for input array #0 with length not of power of two', () => {\n+    const array = [0, 1, 2];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, 0, 1, 0, 1, 2]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build tree for input array #1 with length not of power of two', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([\n+      null, -1, 0, -1, 0, 1, -1, 3, 4, 0, 2, 1,\n+    ]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build max array #0', () => {\n+    const array = [-1, 2, 4, 0];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.max, -Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, 4, 2, 4, -1, 2, 4, 0]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build max array #1', () => {\n+    const array = [-1, 6, 4, 0, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.max, -Infinity);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, 6, 1, 6, 1, -1, 6, 4, 0, 1]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build sum array #0', () => {\n+    const array = [-1, 2, 4, 0];\n+    const segmentTree = new NonRecursiveSegmentTree(array, (a, b) => (a + b), 0);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, 5, 1, 4, -1, 2, 4, 0]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should build sum array #1', () => {\n+    const array = [-1, 6, 4, 0, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, (a, b) => (a + b), 0);\n+\n+    expect(segmentTree.segmentTree).toEqual([null, 10, 0, 10, 1, -1, 6, 4, 0, 1]);\n+    expect(segmentTree.segmentTree.length).toBe(2 * array.length);\n+  });\n+\n+  it('should do min range query on power of two length array', () => {\n+    const array = [-1, 2, 4, 0];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.rangeQuery(0, 3)).toBe(-1);\n+    expect(segmentTree.rangeQuery(0, 1)).toBe(-1);\n+    expect(segmentTree.rangeQuery(1, 3)).toBe(0);\n+    expect(segmentTree.rangeQuery(1, 2)).toBe(2);\n+    expect(segmentTree.rangeQuery(2, 3)).toBe(0);\n+    expect(segmentTree.rangeQuery(2, 2)).toBe(4);\n+  });\n+\n+  it('should do min range query on not power of two length array', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    expect(segmentTree.rangeQuery(0, 5)).toBe(-1);\n+    expect(segmentTree.rangeQuery(0, 2)).toBe(-1);\n+    expect(segmentTree.rangeQuery(1, 3)).toBe(0);\n+    expect(segmentTree.rangeQuery(2, 4)).toBe(0);\n+    expect(segmentTree.rangeQuery(4, 5)).toBe(1);\n+    expect(segmentTree.rangeQuery(2, 2)).toBe(4);\n+  });\n+\n+  it('should do max range query', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.max, -Infinity);\n+\n+    expect(segmentTree.rangeQuery(0, 5)).toBe(4);\n+    expect(segmentTree.rangeQuery(0, 1)).toBe(3);\n+    expect(segmentTree.rangeQuery(1, 3)).toBe(4);\n+    expect(segmentTree.rangeQuery(2, 4)).toBe(4);\n+    expect(segmentTree.rangeQuery(4, 5)).toBe(2);\n+    expect(segmentTree.rangeQuery(3, 3)).toBe(0);\n+  });\n+\n+  it('should do sum range query', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, (a, b) => (a + b), 0);\n+\n+    expect(segmentTree.rangeQuery(0, 5)).toBe(9);\n+    expect(segmentTree.rangeQuery(0, 1)).toBe(2);\n+    expect(segmentTree.rangeQuery(1, 3)).toBe(7);\n+    expect(segmentTree.rangeQuery(2, 4)).toBe(6);\n+    expect(segmentTree.rangeQuery(4, 5)).toBe(3);\n+    expect(segmentTree.rangeQuery(3, 3)).toBe(0);\n+  });\n+\n+  it('should update a position on power of two length array', () => {\n+    const array = [-1, 3, 4, 0];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    segmentTree.positionUpdate(3, -2);\n+    expect(segmentTree.segmentTree).toEqual([null, -2, -1, -2, -1, 3, 4, -2]);\n+    expect(segmentTree.inputArray).toEqual([-1, 3, 4, -2]);\n+  });\n+\n+  it('should update a position on not power of two length array', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.min, Infinity);\n+\n+    segmentTree.positionUpdate(4, -2);\n+    expect(segmentTree.segmentTree).toEqual([null, -2, -2, -1, 0, -2, -1, 3, 4, 0, -2, 1]);\n+    expect(segmentTree.inputArray).toEqual([-1, 3, 4, 0, -2, 1]);\n+  });\n+\n+  it('should update and do range max query', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, Math.max, -Infinity);\n+\n+    segmentTree.positionUpdate(3, 3);\n+    expect(segmentTree.rangeQuery(0, 5)).toEqual(4);\n+    expect(segmentTree.rangeQuery(3, 4)).toEqual(3);\n+    expect(segmentTree.rangeQuery(3, 5)).toEqual(3);\n+    expect(segmentTree.rangeQuery(0, 2)).toEqual(4);\n+    expect(segmentTree.rangeQuery(3, 3)).toEqual(3);\n+    expect(segmentTree.rangeQuery(4, 4)).toEqual(2);\n+    expect(segmentTree.rangeQuery(2, 2)).toEqual(4);\n+  });\n+\n+  it('should update and do range sum query', () => {\n+    const array = [-1, 3, 4, 0, 2, 1];\n+    const segmentTree = new NonRecursiveSegmentTree(array, (a, b) => (a + b), 0);\n+\n+    segmentTree.positionUpdate(3, 3);\n+    expect(segmentTree.rangeQuery(0, 5)).toEqual(12);\n+    expect(segmentTree.rangeQuery(3, 4)).toEqual(5);\n+    expect(segmentTree.rangeQuery(3, 5)).toEqual(6);\n+    expect(segmentTree.rangeQuery(0, 2)).toEqual(6);\n+    expect(segmentTree.rangeQuery(3, 3)).toEqual(3);\n+    expect(segmentTree.rangeQuery(4, 4)).toEqual(2);\n+    expect(segmentTree.rangeQuery(2, 2)).toEqual(4);\n+  });\n+});""}",[]
17,225,open,"This PR adds the Karatsuba fast multiplication algorithm to the `algorithms/math` folder.

**README.md**

# Karatsuba Multiplication

Karatsuba is a fast multiplication algorithm discovered by Anatoly Karatsuba in 1960. Given two n-digit numbers, the ""grade-school"" method of long multiplication has a time complexity of O(n<sup>2</sup>), whereas the karatsuba algorithm has a time complexity of O(n<sup>1.59</sup>).

## Recursive Formula

```
x = 1234
y = 5678

karatsuba(x, y)
```

1. Split each number into numbers with half as many digits
```
a = 12
b = 34

c = 56
d = 78
```

2. Compute 3 subexpressions from the smaller numbers
  - `ac = a * c`
  - `bd = b * d`
  - `abcd = (a + b) * (c + d)`

3. Combine subexpressions to calculate the product
```
A = ac * 10000
B = (abcd - ac - bd) * 100
C = bd

x * y = A + B + C
```

_**Note:**_ *The karatsuba algorithm can be applied recursively to calculate each product in the subexpressions.* (`a * c = karatsuba(a, c)`*). When the numbers get smaller than some arbitrary threshold, they are multiplied in the traditional way.*

## References
[Stanford Algorithms (YouTube)](https://www.youtube.com/watch?v=JCbZayFr9RE)
[Wikipedia](https://en.wikipedia.org/wiki/Karatsuba_algorithm)
",3,"['src/algorithms/math/karatsuba-multiplication/README.md', 'src/algorithms/math/karatsuba-multiplication/__test__/karatsuba.test.js', 'src/algorithms/math/karatsuba-multiplication/karatsuba.js']",4,"['add karatsuba multiplication algorithm', 'add partial README', 'finish README', 'fix typos']","{'Name': 'src/algorithms/math/karatsuba-multiplication/karatsuba.js', 'Line Additions': 68, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,68 @@\n+/**\n+ *\n+ * @param {number} x\n+ * @param {number} y\n+ * @return {number}\n+ */\n+export default function karatsuba(x, y) {\n+  // BASE CASE:\n+  // if numbers are sufficiently small,\n+  // multiply them together in the traditional way\n+  if (x < 10 || y < 10) {\n+    return x * y;\n+  }\n+\n+  // SCALE FACTOR:\n+  // scaleFactor is used to split the numbers\n+  // into smaller numbers for recursion.\n+  // when combining the subexpressions back\n+  // together, the scaleFactor is used to\n+  // recreate the magnitude of the original numbers\n+  const minDigits = Math.min(\n+    String(x).length,\n+    String(y).length,\n+  );\n+  const scaleFactor = 10 ** Math.floor(minDigits / 2);\n+\n+  // PARAMETER COMPONENTS:\n+  // a b are the two components of x\n+  // c d are the two components of y\n+  //\n+  // e.g.\n+  // x = 1234 -> a = 12, b = 34\n+  // y = 5678 -> c = 56, d = 78\n+\n+  // example of component computations:\n+  // x = 1234, y = 5678\n+  // scaleFactor = 100\n+\n+  // a = floor(1234 / 100) = floor(12.34) = 12\n+  const a = Math.floor(x / scaleFactor);\n+\n+  // b = 1234 - (12 * 100) = 1234 - 1200 = 34\n+  const b = x - (a * scaleFactor);\n+\n+  // c = floor(5678 / 100) = floor(56.78) = 56\n+  const c = Math.floor(y / scaleFactor);\n+\n+  // d = 5678 - (56 * 100) = 5678 - 5600 = 78\n+  const d = y - (c * scaleFactor);\n+\n+  // COMPUTE SUBEXPRESSIONS:\n+  // since a + b is less than x, and c + d is less than y\n+  // the recursion is guaranteed to reach the base case\n+  const ac = karatsuba(a, c);\n+  const bd = karatsuba(b, d);\n+  const abcd = karatsuba(a + b, c + d);\n+\n+  // COMBINE SUBEXPRESSIONS:\n+  // since the scaleFactor was used to\n+  // reduce the size of the components,\n+  // the scaleFactor must be applied in reverse\n+  // to reconstruct the magnitude of the original components\n+  const A = ac * (scaleFactor ** 2);\n+  const B = (abcd - ac - bd) * scaleFactor;\n+  const C = bd;\n+\n+  return A + B + C;\n+}'}",[]
18,231,open,"1. use `currentIndex - 1 >= 0` instead `array[currentIndex - 1] !== undefined` in while-loop, I think it should be more readable.
2. swap value with destructuring assignment

some thoughts:
Since the for-loop in InsertionSort should start from `1`(in `0` it will just pass the while-loop), I think `for (let i = 1; i < array.length; i += 1)` would be a better idea.",1,['src/algorithms/sorting/insertion-sort/InsertionSort.js'],2,"['InsertionSort: use index to compare instead `undefined`', 'InserationSort: fix lint']","{'Name': 'src/algorithms/sorting/insertion-sort/InsertionSort.js', 'Line Additions': 3, 'Line Deletions': 4, 'Patch': '@@ -14,16 +14,15 @@ export default class InsertionSort extends Sort {\n       // Go and check if previous elements and greater then current one.\n       // If this is the case then swap that elements.\n       while (\n-        array[currentIndex - 1] !== undefined\n+        currentIndex - 1 >= 0\n         && this.comparator.lessThan(array[currentIndex], array[currentIndex - 1])\n       ) {\n         // Call visiting callback.\n         this.callbacks.visitingCallback(array[currentIndex - 1]);\n \n         // Swap the elements.\n-        const tmp = array[currentIndex - 1];\n-        array[currentIndex - 1] = array[currentIndex];\n-        array[currentIndex] = tmp;\n+        [array[currentIndex - 1], array[currentIndex]] = [\n+          array[currentIndex], array[currentIndex - 1]];\n \n         // Shift current index left.\n         currentIndex -= 1;'}",[]
19,237,open,,1,['bfs'],1,['Create bfs'],"{'Name': 'bfs', 'Line Additions': 92, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,92 @@\n+#include<iostream> \n+#include <list> \n+  \n+using namespace std; \n+  \n+// This class represents a directed graph using \n+// adjacency list representation \n+class Graph \n+{ \n+    int V;    // No. of vertices \n+  \n+    // Pointer to an array containing adjacency \n+    // lists \n+    list<int> *adj;    \n+public: \n+    Graph(int V);  // Constructor \n+  \n+    // function to add an edge to graph \n+    void addEdge(int v, int w);  \n+  \n+    // prints BFS traversal from a given source s \n+    void BFS(int s);   \n+}; \n+  \n+Graph::Graph(int V) \n+{ \n+    this->V = V; \n+    adj = new list<int>[V]; \n+} \n+  \n+void Graph::addEdge(int v, int w) \n+{ \n+    adj[v].push_back(w); // Add w to v’s list. \n+} \n+  \n+void Graph::BFS(int s) \n+{ \n+    // Mark all the vertices as not visited \n+    bool *visited = new bool[V]; \n+    for(int i = 0; i < V; i++) \n+        visited[i] = false; \n+  \n+    // Create a queue for BFS \n+    list<int> queue; \n+  \n+    // Mark the current node as visited and enqueue it \n+    visited[s] = true; \n+    queue.push_back(s); \n+  \n+    // \'i\' will be used to get all adjacent \n+    // vertices of a vertex \n+    list<int>::iterator i; \n+  \n+    while(!queue.empty()) \n+    { \n+        // Dequeue a vertex from queue and print it \n+        s = queue.front(); \n+        cout << s << "" ""; \n+        queue.pop_front(); \n+  \n+        // Get all adjacent vertices of the dequeued \n+        // vertex s. If a adjacent has not been visited,  \n+        // then mark it visited and enqueue it \n+        for (i = adj[s].begin(); i != adj[s].end(); ++i) \n+        { \n+            if (!visited[*i]) \n+            { \n+                visited[*i] = true; \n+                queue.push_back(*i); \n+            } \n+        } \n+    } \n+} \n+  \n+// Driver program to test methods of graph class \n+int main() \n+{ \n+    // Create a graph given in the above diagram \n+    Graph g(4); \n+    g.addEdge(0, 1); \n+    g.addEdge(0, 2); \n+    g.addEdge(1, 2); \n+    g.addEdge(2, 0); \n+    g.addEdge(2, 3); \n+    g.addEdge(3, 3); \n+  \n+    cout << ""Following is Breadth First Traversal ""\n+         << ""(starting from vertex 2) \\n""; \n+    g.BFS(2); \n+  \n+    return 0; \n+} '}",[]
20,239,open,"* Sort in-place without copying the orignal input
* Remove `recursiveCall` param from `sort` method as not needed anymore
* Extract `partitionArray` function to class method
* Remove `swap` function - use destructuring instead
* Call `visitingCallback` with the right arguments - in this case with `pivot`",2,"['src/algorithms/sorting/quick-sort/QuickSortInPlace.js', 'src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js']",2,"['Refactor QuickSortInPlace\n\n* Sort in place without copying the orignal input\n* Remove `recursiveCall` param from `sort` method as not needed anymore\n* Extract `partitionArray` function to class method\n* Remove `swap` function - use destructuring instead\n* Call `visitingCallback` with the right arguments - in this case with `pivot`', ""Merge branch 'master' into quick-sort-refactor""]","{'Name': 'src/algorithms/sorting/quick-sort/__test__/QuickSortInPlace.test.js', 'Line Additions': 1, 'Line Deletions': 1, 'Patch': '@@ -9,7 +9,7 @@ import {\n \n // Complexity constants.\n const SORTED_ARRAY_VISITING_COUNT = 19;\n-const NOT_SORTED_ARRAY_VISITING_COUNT = 12;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 19;\n const REVERSE_SORTED_ARRAY_VISITING_COUNT = 19;\n const EQUAL_ARRAY_VISITING_COUNT = 19;\n '}",[]
21,241,open,"Hi,

I have implemented a beginner sorting algorithm known as Odd-Even sorting (also known as Brick sort).

",5,"['README.md', 'package-lock.json', 'src/algorithms/sorting/odd-even-sort/OddEvenSort.js', 'src/algorithms/sorting/odd-even-sort/README.md', 'src/algorithms/sorting/odd-even-sort/__test__/OddEvenSort.test.js']",7,"['first commit for odd even sorting', 'adding the test cases', ""Added in all the test cases and fixed the visiting count since it states 'each time the sorting function is visiting the next element.'"", 'Added Odd-Even to the main read me', 'Added details about the sort in the readme', ""Merge branch 'master' into Odd-even-Sort"", 'Delete package-lock.json']","{'Name': 'src/algorithms/sorting/odd-even-sort/__test__/OddEvenSort.test.js', 'Line Additions': 64, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,64 @@\n+import OddEvenSort from '../OddEvenSort';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+const EQUAL_ARRAY_VISITING_COUNT = 19;\n+const SORTED_ARRAY_VISITING_COUNT = 19;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 171;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 209;\n+\n+describe('OddEvenSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(OddEvenSort);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(OddEvenSort);\n+  });\n+\n+  it('should do stable sorting', () => {\n+    SortTester.testSortStability(OddEvenSort);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(OddEvenSort);\n+  });\n+\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      OddEvenSort,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      OddEvenSort,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      OddEvenSort,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      OddEvenSort,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+});""}",[]
22,246,open,"This algorithm is O(nlogn + M), where M is the number of edges in the graph.",2,"['src/algorithms/graph/topological-sorting/__test__/topologicalSortByCounting.test.js', 'src/algorithms/graph/topological-sorting/topologicalSortByCounting.js']",1,"[""Implements Khan's topological sorting algorithm as described on wikipedia: https://en.wikipedia.org/wiki/Topological_sorting""]","{'Name': 'src/algorithms/graph/topological-sorting/topologicalSortByCounting.js', 'Line Additions': 45, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,45 @@\n+import PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';\n+\n+/**\n+ * @param {Graph} graph\n+ * Implements Khan's algorithms\n+ */\n+export default function topologicalSort(graph) {\n+  // Count the preceders for all ndoes.\n+  const precederCounts = {};\n+\n+  // Order nodes by number of preceders.\n+  const priorityQueue = new PriorityQueue();\n+\n+  // The resulting sorted list.\n+  const sortedStack = [];\n+\n+  // Initialize the counter array.\n+  graph.getAllVertices().forEach((vertex) => {\n+    precederCounts[vertex.getKey()] = 0;\n+  });\n+\n+  // Count preceders for all nodes.\n+  graph.getAllEdges().forEach((edge) => {\n+    precederCounts[edge.endVertex.getKey()] = precederCounts[edge.endVertex.getKey()] + 1;\n+  });\n+\n+  graph.getAllVertices().forEach((vertex) => {\n+    priorityQueue.add(vertex, precederCounts[vertex.getKey()]);\n+  });\n+\n+  while (!priorityQueue.isEmpty()) {\n+    const vertex = priorityQueue.poll();\n+\n+    sortedStack.push(vertex);\n+    vertex.getEdges().forEach((edge) => {\n+      // Decrease counter for all child nodes.\n+      precederCounts[edge.endVertex.getKey()] = precederCounts[edge.endVertex.getKey()] - 1;\n+\n+      // Update the information in priority queue.\n+      priorityQueue.changePriority(edge.endVertex, precederCounts[edge.endVertex.getKey()]);\n+    });\n+  }\n+\n+  return sortedStack;\n+}""}",[]
23,255,open,Edit awkward grammar / Add algorithm explanation,1,['README.ko-KR.md'],2,"['updata README.ko-KR.md from README', ""Merge branch 'master' into develop""]","{'Name': 'README.ko-KR.md', 'Line Additions': 42, 'Line Deletions': 40, 'Patch': '@@ -3,7 +3,7 @@\n [![Build Status](https://travis-ci.org/trekhleb/javascript-algorithms.svg?branch=master)](https://travis-ci.org/trekhleb/javascript-algorithms)\n [![codecov](https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg)](https://codecov.io/gh/trekhleb/javascript-algorithms)\n \n-이 저장소에는 많이 알려진 알고리즘 및 자료 구조의 Javascript 기반 예제를 담고 있습니다.\n+이 저장소에는 Javascript 버전의 저명한 알고리즘 및 자료 구조의 예제를 담고 있습니다.\n \n 각 알고리즘과 자료 구조에 대해 연관되어있는 설명이 README에 작성되어 있으며,\n 링크를 통해 더 자세한 설명을 만날 수 있습니다. (관련된 YouTube 영상도 포함).\n@@ -19,25 +19,26 @@ _Read this in other languages:_\n \n ## 자료 구조\n \n-자료 구조는 데이터를 특정 방식으로 구성하고 저장함으로써 더 효율적으로\n-접근하고 수정할 수 있게 해줍니다. 간단히 말해, 자료 구조는 데이터 값들,\n-데이터 간의 관계, 그리고 데이터를 다룰 수 있는 함수와 작업의 모임입니다. \n+자료 구조는 데이터 값들, 데이터 값들 간의 관계, \n+그리고 데이터를 다룰 수 있는 함수와 연산들의 집합으로, \n+데이터를 특정 방식으로 구성하고 저장함으로써 더 효율적으로\n+접근하고 수정할 수 있게 해줍니다.   \n \n \n `B` - 입문자, `A` - 숙련자\n \n * `B` [연결 리스트](src/data-structures/linked-list)\n * `B` [이중 연결 리스트](src/data-structures/doubly-linked-list)\n-* `B` [큐](src/data-structures/queue)\n-* `B` [스택](src/data-structures/stack)\n+* `B` [큐](src/data-structures/queue) - 선입선출 방식\n+* `B` [스택](src/data-structures/stack) - 후입선출 방식\n * `B` [해시 테이블](src/data-structures/hash-table)\n * `B` [힙](src/data-structures/heap)\n * `B` [우선순위 큐](src/data-structures/priority-queue)\n * `A` [트라이](src/data-structures/trie)\n * `A` [트리](src/data-structures/tree)\n   * `A` [이진 탐색 트리](src/data-structures/tree/binary-search-tree)\n-  * `A` [AVL 트리](src/data-structures/tree/avl-tree)\n-  * `A` [Red-Black 트리](src/data-structures/tree/red-black-tree)\n+  * `A` [AVL 트리](src/data-structures/tree/avl-tree) - 균형 잡힌 이진 탐색 트리\n+  * `A` [Red-Black 트리](src/data-structures/tree/red-black-tree) - 자가 균형 이진 탐색 트리\n   * `A` [세그먼트 트리](src/data-structures/tree/segment-tree) - min/max/sum range 쿼리 예제.\n   * `A` [Fenwick 트리](src/data-structures/tree/fenwick-tree) (Binary Indexed Tree)\n * `A` [그래프](src/data-structures/graph) (유방향, 무방향)\n@@ -46,23 +47,24 @@ _Read this in other languages:_\n \n ## 알고리즘\n \n-알고리즘은 어떤 종류의 문제를 풀 수 있는 정확한 방법이며, \n-일련의 작업을 정확하게 정의해 놓은 규칙들입니다. \n+알고리즘은 어떠한 문제를 해결하기 위해 정해진 \n+일련의 절차나 방법을 공식화한 형태로 표현한 것을 말한다.\n+\n \n `B` - 입문자, `A` - 숙련자\n \n ### 주제별 알고리즘\n \n * **Math**\n-  * `B` [Bit Manipulation](src/algorithms/math/bits) - set/get/update/clear bits, 2의 곱 / 나누기, 음수로 만들기 etc.\n-  * `B` [팩토리얼](src/algorithms/math/factorial) \n-  * `B` [피보나치 수](src/algorithms/math/fibonacci)\n+  * `B` [비트 조작](src/algorithms/math/bits) - set/get/update/clear bits, 2의 곱 / 나누기, 음수로 만들기 etc.\n+  * `B` [팩토리얼](src/algorithms/math/factorial) - 그 수보다 작거나 같은 모든 양의 정수의 곱\n+  * `B` [피보나치 수](src/algorithms/math/fibonacci) - 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열\n   * `B` [소수 판별](src/algorithms/math/primality-test) (trial division 방식)\n   * `B` [유클리드 호제법](src/algorithms/math/euclidean-algorithm) - 최대공약수 (GCD)\n-  * `B` [최소 공배수](src/algorithms/math/least-common-multiple) - LCM\n+  * `B` [최소 공배수](src/algorithms/math/least-common-multiple) - LCM(Least Common Multiple)\n   * `B` [에라토스테네스의 체](src/algorithms/math/sieve-of-eratosthenes) - 특정수 이하의 모든 소수 찾기\n   * `B` [2의 거듭제곱 판별법](src/algorithms/math/is-power-of-two) - 어떤 수가 2의 거듭제곱인지 판별 (naive 와 bitwise 알고리즘)\n-  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle)\n+  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle) - 이항계수를 삼각형 모양의 기하학적 형태로 배열한 것\n   * `A` [자연수 분할](src/algorithms/math/integer-partition)\n   * `A` [리우 후이 π 알고리즘](src/algorithms/math/liu-hui) - N-각형을 기반으로 π 근사치 구하기\n * **Sets**\n@@ -73,7 +75,7 @@ _Read this in other languages:_\n   * `A` [조합](src/algorithms/sets/combinations) (반복 유,무)\n   * `A` [최장 공통 부분수열](src/algorithms/sets/longest-common-subsequence) (LCS)\n   * `A` [최장 증가 수열](src/algorithms/sets/longest-increasing-subsequence)\n-  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence) (SCS)\n+  * `A` [최단 공통 상위수열](src/algorithms/sets/shortest-common-supersequence) (SCS)\n   * `A` [배낭 문제](src/algorithms/sets/knapsack-problem) - ""0/1"" 과 ""Unbound""\n   * `A` [최대 구간합](src/algorithms/sets/maximum-subarray) - ""브루트 포스"" 과 ""동적 계획법"" (Kadane\'s) 버전\n   * `A` [조합 합](src/algorithms/sets/combination-sum) - 특정 합을 구성하는 모든 조합 찾기\n@@ -83,23 +85,23 @@ _Read this in other languages:_\n   * `A` [커누스-모리스-프랫 알고리즘](src/algorithms/string/knuth-morris-pratt) (KMP 알고리즘) - 부분 문자열 탐색 (패턴 매칭)\n   * `A` [Z 알고리즘](src/algorithms/string/z-algorithm) - 부분 문자열 탐색 (패턴 매칭)\n   * `A` [라빈 카프 알고리즘](src/algorithms/string/rabin-karp) - 부분 문자열 탐색\n-  * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring)\n+  * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring) - 부분 문자열 탐색\n   * `A` [정규 표현식 매칭](src/algorithms/string/regular-expression-matching)\n * **Searches**\n   * `B` [선형 탐색](src/algorithms/search/linear-search)\n   * `B` [점프 탐색](src/algorithms/search/jump-search) (or Block Search) - 정렬된 배열에서 탐색\n   * `B` [이진 탐색](src/algorithms/search/binary-search) - 정렬된 배열에서 탐색\n   * `B` [보간 탐색](src/algorithms/search/interpolation-search) - 균등한 분포를 이루는 정렬된 배열에서 탐색\n * **Sorting**\n-  * `B` [거품 정렬](src/algorithms/sorting/bubble-sort)\n-  * `B` [선택 정렬](src/algorithms/sorting/selection-sort)\n-  * `B` [삽입 정렬](src/algorithms/sorting/insertion-sort)\n-  * `B` [힙 정렬](src/algorithms/sorting/heap-sort)\n-  * `B` [병합 정렬](src/algorithms/sorting/merge-sort)\n+  * `B` [거품 정렬](src/algorithms/sorting/bubble-sort) (bubble-sort)\n+  * `B` [선택 정렬](src/algorithms/sorting/selection-sort) (selection sort)\n+  * `B` [삽입 정렬](src/algorithms/sorting/insertion-sort) (insertion sort)\n+  * `B` [힙 정렬](src/algorithms/sorting/heap-sort) (heap sort)\n+  * `B` [병합 정렬](src/algorithms/sorting/merge-sort) (merge sort)\n   * `B` [퀵 정렬](src/algorithms/sorting/quick-sort) - 제자리(in-place)와 제자리가 아닌(non-in-place) 구현\n-  * `B` [셸 정렬](src/algorithms/sorting/shell-sort)\n-  * `B` [계수 정렬](src/algorithms/sorting/counting-sort)\n-  * `B` [기수 정렬](src/algorithms/sorting/radix-sort)\n+  * `B` [셸 정렬](src/algorithms/sorting/shell-sort) (shell sort)\n+  * `B` [계수 정렬](src/algorithms/sorting/counting-sort) (counting sort)\n+  * `B` [기수 정렬](src/algorithms/sorting/radix-sort) (radix sort)\n * **Trees**\n   * `B` [깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)\n   * `B` [너비 우선 탐색](src/algorithms/tree/breadth-first-search) (BFS)\n@@ -120,13 +122,13 @@ _Read this in other languages:_\n   * `A` [강결합 컴포넌트](src/algorithms/graph/strongly-connected-components) - Kosaraju의 알고리즘\n   * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기\n * **Uncategorized**\n-  * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower)\n+  * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower) - 재귀 호출을 이용한 알고리즘 예제\n   * `B` [정방 행렬 회전](src/algorithms/uncategorized/square-matrix-rotation) - 제자리(in-place) 알고리즘\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game) - 백트래킹, 동적계획법 (top-down + bottom-up), 탐욕 알고리즘 예제 \n   * `B` [Unique 경로](src/algorithms/uncategorized/unique-paths) - 백트래킹, 동적계획법, 파스칼 삼각형에 기반한 예제\n   * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem (동적계획법, 브루트포스 버전)\n-  * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)\n-  * `A` [기사의 여행 문제](src/algorithms/uncategorized/knight-tour)\n+  * `A` [N개의 퀸 문제](src/algorithms/uncategorized/n-queens) - NXN 체스판에 N개의 퀸을 배치하는 문제\n+  * `A` [기사의 여행 문제](src/algorithms/uncategorized/knight-tour) - 체스 보드의 기사 말에 대한 수학적 알고리즘\n \n ### 패러다임별 알고리즘\n \n@@ -141,32 +143,32 @@ _Read this in other languages:_\n   * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기\n * **탐욕 알고리즘(Greedy)** - 이후를 고려하지 않고 현재 시점에서 가장 최적인 선택을 하는 방식입니다.\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n-  * `A` [쪼갤수 있는 배낭 문제](src/algorithms/sets/knapsack-problem)\n+  * `A` [쪼갤수 있는 배낭 문제](src/algorithms/sets/knapsack-problem) - 짐들을 배낭에 넣을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제\n   * `A` [다익스트라 알고리즘](src/algorithms/graph/dijkstra) - 모든 점 까지의 최단거리 찾기\n   * `A` [프림 알고리즘](src/algorithms/graph/prim) - 무방향 가중치 그래프에서 최소 신창 트리 (MST) 찾기\n   * `A` [크루스칼 알고리즘](src/algorithms/graph/kruskal) - 무방향 가중치 그래프에서 최소 신창 트리 (MST) 찾기\n * **분할 정복법(Divide and Conquer)** - 문제를 여러 작은 문제로 분할한 뒤 해결하는 방식입니다.\n-  * `B` [이진 탐색](src/algorithms/search/binary-search)\n-  * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower)\n-  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle)\n+  * `B` [이진 탐색](src/algorithms/search/binary-search) - 정렬된 배열에서 탐색\n+  * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower) - 재귀 호출을 이용한 알고리즘 예제\n+  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle) - 이항계수를 삼각형 모양의 기하학적 형태로 배열한 것\n   * `B` [유클리드 호제법](src/algorithms/math/euclidean-algorithm) - 최대공약수 계산 (GCD)\n-  * `B` [병합 정렬](src/algorithms/sorting/merge-sort)\n-  * `B` [퀵 정렬](src/algorithms/sorting/quick-sort)\n+  * `B` [병합 정렬](src/algorithms/sorting/merge-sort) (merge sort)\n+  * `B` [퀵 정렬](src/algorithms/sorting/quick-sort) - 제자리(in-place)와 제자리가 아닌(non-in-place) 구현\n   * `B` [트리 깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)\n   * `B` [그래프 깊이 우선 탐색](src/algorithms/graph/depth-first-search) (DFS)\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n   * `A` [순열](src/algorithms/sets/permutations) (반복 유,무)\n   * `A` [조합](src/algorithms/sets/combinations) (반복 유,무)\n * **동적 계획법(Dynamic Programming)** - 이전에 찾은 결과를 이용하여 최종적으로 해결하는 방식입니다.\n-  * `B` [피보나치 수](src/algorithms/math/fibonacci)\n+  * `B` [피보나치 수](src/algorithms/math/fibonacci) - 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n-  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n+  * `B` [Unique 경로](src/algorithms/uncategorized/unique-paths) - 백트래킹, 동적계획법, 파스칼 삼각형에 기반한 예제\n   * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem\n   * `A` [편집 거리](src/algorithms/string/levenshtein-distance) - 두 시퀀스 간의 최소 편집 거리\n   * `A` [최장 공통 부분 수열](src/algorithms/sets/longest-common-subsequence) (LCS)\n   * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring)\n   * `A` [최장 증가 수열](src/algorithms/sets/longest-increasing-subsequence)\n-  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence)\n+  * `A` [최단 공통 상위수열](src/algorithms/sets/shortest-common-supersequence) (SCS)\n   * `A` [0/1 배낭 문제](src/algorithms/sets/knapsack-problem)\n   * `A` [자연수 분할](src/algorithms/math/integer-partition)\n   * `A` [최대 구간합](src/algorithms/sets/maximum-subarray)\n@@ -175,10 +177,10 @@ _Read this in other languages:_\n   * `A` [정규 표현식 매칭](src/algorithms/string/regular-expression-matching)\n * **백트래킹(Backtracking)** - 모든 가능한 경우를 고려한다는 점에서 브루트 포스와 유사합니다. 하지만 다음 단계로 넘어갈때 마다 모든 조건을 만족했는지 확인하고 진행합니다. 만약 조건을 만족하지 못했다면 뒤로 돌아갑니다 (백트래킹). 그리고 다른 경로를 선택합니다. 보통 상태를  유지한 DFS 탐색을 많이 사용합니다.\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n-  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n+  * `B` [Unique 경로](src/algorithms/uncategorized/unique-paths) - 백트래킹, 동적계획법, 파스칼 삼각형에 기반한 예제\n   * `A` [해밀턴 경로](src/algorithms/graph/hamiltonian-cycle) - 모든 점을 한번씩 방문\n-  * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)\n-  * `A` [기사의 여행](src/algorithms/uncategorized/knight-tour)\n+  * `A` [N개의 퀸 문제](src/algorithms/uncategorized/n-queens) - NXN 체스판에 N개의 퀸을 배치하는 문제\n+  * `A` [기사의 여행 문제](src/algorithms/uncategorized/knight-tour) - 체스 보드의 기사 말에 대한 수학적 알고리즘\n   * `A` [조합 합](src/algorithms/sets/combination-sum) - 특정 합을 구성하는 모든 조합 찾기\n * **분기 한정법** - 백트래킹으로 찾은 각 단계의 최소 비용 해결법을 기억해 두고 있다가, 이 비용을 이용해서 더 낮은 최소 비용을 찾습니다. 기억해둔 최소 비용을 이용해 더 높은 비용이 드는 해결법은 더이상 탐색하지 않습니다. 보통 상태 정보를 사진 DFS 를 이용한 BFS 방식에서 사용됩니다.\n '}",[]
24,256,open,,3,"['README.ko-KR.md', 'src/algorithms/graph/astar-algorithm/README.md', 'src/algorithms/graph/astar-algorithm/astar.js']",7,"['updata README.ko-KR.md from README', 'add astar algorithm', 'fix astar-algorithm astar.js', 'fix astar algorithm astar.js', 'fix astar algorithm astar.js', 'fix astar algorithm astar.js', 'fix astar algorithm astar.js']","{'Name': 'src/algorithms/graph/astar-algorithm/astar.js', 'Line Additions': 85, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,85 @@\n+import PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';\n+/**\n+ * @param {Graph} graph\n+ * @param {GraphVertex} startVertex\n+ */\n+// calculate heuristic cost(number of hop from start to end)\n+function heuristicCost(graph, startNode, endNode) {\n+  const arr = [];\n+  let count = 1;\n+  graph.getNeighbors(startNode).forEach((vertex) => {\n+    arr.push(vertex);\n+  });\n+  while (true) {\n+    if (arr.indexOf(endNode) !== -1) {\n+      break;\n+    }\n+    arr.forEach((vertex) => {\n+      graph.getNeighbors(vertex).forEach((child) => {\n+        arr.push(child);\n+      });\n+      arr.remove(arr.indexOf(vertex));\n+    });\n+    count += 1;\n+  }\n+  return count;\n+}\n+export default function astar(graph, startVertex, endVertex) {\n+  const distances = {};\n+  const heuristic = {};\n+  const previousVertices = {};\n+  const closed = {};\n+  const open = new PriorityQueue();\n+  let currentVertex = null;\n+  // Init all distances with infinity assuming that currently we can't reach\n+  // any of the vertices except start one.\n+  graph.getAllVertices().forEach((vertex) => {\n+    distances[vertex.getKey()] = Infinity;\n+    previousVertices[vertex.getKey()] = null;\n+    closed[vertex.getKey()] = null;\n+    heuristic[vertex.getKey()] = heuristicCost(graph, vertex, endVertex);\n+  });\n+  distances[startVertex.getKey()] = 0;\n+  heuristic[startVertex.getKey()] = 0;\n+  // Init vertices queue.\n+  open.add(startVertex, distances[startVertex.getKey()] + heuristic[startVertex.getKey()]);\n+  while (!open.isEmpty()) {\n+    while (true) {\n+      currentVertex = open.poll();\n+      const currentKey = currentVertex.getKey();\n+      open.remove(currentVertex);\n+      if (!closed[currentVertex.getKey()]) {\n+        break;\n+      } else if (closed[currentKey] > distances[currentKey] + heuristic[currentKey]) {\n+        closed[currentKey] = distances[currentKey] + heuristic[currentKey];\n+        break;\n+      }\n+    }\n+    // Add current vertex to visited ones.\n+    closed[currentVertex.getKey()] = distances[currentVertex.getKey()];\n+    graph.getNeighbors(currentVertex).forEach((neighbor) => {\n+      // Update distances to every neighbor from current vertex.\n+      const edge = graph.findEdge(currentVertex, neighbor);\n+      const existingDistanceToNeighbor = distances[neighbor.getKey()];\n+      const distanceToNeighborFromCurrent = distances[currentVertex.getKey()] + edge.weight;\n+      const neighborKey = neighbor.getKey();\n+      if (distanceToNeighborFromCurrent < existingDistanceToNeighbor) {\n+        distances[neighborKey] = distanceToNeighborFromCurrent;\n+        // Change priority.\n+        if (open.hasValue(neighbor)) {\n+          open.changePriority(neighbor, distances[neighborKey] + heuristic[neighborKey]);\n+        }\n+        // Remember previous vertex.\n+        previousVertices[neighborKey] = currentVertex;\n+      }\n+      // Add neighbor to the queue for further visiting.\n+      if (!open.hasValue(neighbor)) {\n+        open.add(neighbor, distances[neighborKey] + heuristic[neighborKey]);\n+      }\n+    });\n+  }\n+  return {\n+    distances,\n+    previousVertices,\n+  };\n+}""}",[]
25,258,open,add Lowest Common Ancestor algorithm,2,"['src/algorithms/tree/lowest-common-ancestor/README.md', 'src/algorithms/tree/lowest-common-ancestor/lowestCommonAncestor.js']",8,"['add Lowest Common Ancestor algorithm', 'update lowestCommonAncestor.js', 'updata lowest common ancestor.js', 'update lower common ancestor js', 'update LCA algorithm', 'update LCA algorithm', 'update LCA algorithm', 'update LCA algorithms']","{'Name': 'src/algorithms/tree/lowest-common-ancestor/lowestCommonAncestor.js', 'Line Additions': 55, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,55 @@\n+/**\n+ * @typedef {Object} Callbacks\n+ * @property {function(node: BinaryTreeNode, child: BinaryTreeNode): boolean} allowTraversal -\n+ *   Determines whether DFS should traverse from the node to its child.\n+ */\n+\n+/**\n+ * @param {Callbacks} [callbacks]\n+ * @returns {Callbacks}\n+ */\n+\n+/**\n+ * @param {BinaryTreeNode} rootNode\n+ * @param {Callbacks} [originalCallbacks]\n+ */\n+function calcDepth(node) {\n+  let depth = 0;\n+  let tempNode = null;\n+  tempNode = node;\n+  while (tempNode.parent == null) {\n+    tempNode = tempNode.parent;\n+    depth += 1;\n+  }\n+\n+  return depth;\n+}\n+\n+/* lowest common ancestor */\n+export default function lca(rootNode, firstNode, secondNode) {\n+  const firstDepth = calcDepth(firstNode);\n+  const secondDepth = calcDepth(secondNode);\n+  let firstOne = null;\n+  let secondOne = null;\n+  firstOne = firstNode;\n+  secondOne = secondNode;\n+\n+  for (let i = 0; i < Math.abs(firstDepth - secondDepth); i += 1) {\n+    if (firstDepth > secondDepth) {\n+      firstOne = firstOne.parent;\n+    } else {\n+      secondOne = secondOne.parent;\n+    }\n+  }\n+\n+  if (firstNode === secondNode) {\n+    return firstOne;\n+  }\n+\n+  while (firstOne !== secondOne) {\n+    firstOne = firstOne.parent;\n+    secondOne = secondOne.parent;\n+  }\n+\n+  return firstOne;\n+}'}",[]
26,261,open,"Huffman coding algorithm, one of the greedy algorithms, seems to be missing.",3,"['src/algorithms/uncategorized/huffman-coding/README.md', 'src/algorithms/uncategorized/huffman-coding/__test__/huffmanCoding.test.js', 'src/algorithms/uncategorized/huffman-coding/huffmanCoding.js']",1,['[ADD] Add huffman coding algorithm'],"{'Name': 'src/algorithms/uncategorized/huffman-coding/huffmanCoding.js', 'Line Additions': 119, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,119 @@\n+var Heap = function(fn) {\n+  this.fn = fn || function(e) {\n+    return e;\n+  };\n+  this.items = [];\n+};\n+\n+Heap.prototype = {\n+  swap: function(i, j) {\n+    this.items[i] = [\n+      this.items[j],\n+      this.items[j] = this.items[i]\n+    ][0];\n+  },\n+  bubble: function(index) {\n+    var parent = ~~((index - 1) / 2);\n+    if (this.item(parent) < this.item(index)) {\n+      this.swap(index, parent);\n+      this.bubble(parent);\n+    }\n+  },\n+  item: function(index) {\n+    return this.fn(this.items[index]);\n+  },\n+  pop: function() {\n+    return this.items.pop();\n+  },\n+  sift: function(index, end) {\n+    var child = index * 2 + 1;\n+    if (child < end) {\n+      if (child + 1 < end && this.item(child + 1) > this.item(child)) {\n+        child++;\n+      }\n+      if (this.item(index) < this.item(child)) {\n+        this.swap(index, child);\n+        return this.sift(child, end);\n+      }\n+    }\n+  },\n+  push: function() {\n+    var lastIndex = this.items.length;\n+    for (var i = 0; i < arguments.length; i++) {\n+      this.items.push(arguments[i]);\n+      this.bubble(lastIndex++);\n+    }\n+  },\n+  get length() {\n+    return this.items.length;\n+  }\n+};\n+\n+var Huffman = {\n+  // encode function\n+  encode: function(data) {\n+    var prob = {};\n+    var tree = new Heap(function(e) {\n+      return e[0];\n+    });\n+    for (var i = 0; i < data.length; i++) {\n+      if (prob.hasOwnProperty(data[i])) {\n+        prob[data[i]]++;\n+      } else {\n+        prob[data[i]] = 1;\n+      }\n+    }\n+    Object.keys(prob).sort(function(a, b) {\n+      return ~~(Math.random() * 2);\n+    }).forEach(function(e) {\n+      tree.push([prob[e], e]);\n+    });\n+    while (tree.length > 1) {\n+      var first = tree.pop(),\n+          second = tree.pop();\n+      tree.push([first[0] + second[0], [first[1], second[1]]]);\n+    }\n+    var dict = {};\n+    var recurse = function(root, string) {\n+      if (root.constructor === Array) {\n+        recurse(root[0], string + '0');\n+        recurse(root[1], string + '1');\n+      } else {\n+        dict[root] = string;\n+      }\n+    };\n+    tree.items = tree.pop()[1];\n+    recurse(tree.items, '');\n+    var result = '';\n+    for (var i = 0; i < data.length; i++) {\n+      result += dict[data.charAt(i)];\n+    }\n+    var header = Object.keys(dict).map(function(e) {\n+      return e.charCodeAt(0) + '|' + dict[e];\n+    }).join('-') + '/';\n+    return header + result;\n+  },\n+  // decode function\n+  decode: function(string) {\n+    string = string.split('/');\n+    var data = string[1].split(''),\n+        header = {};\n+    string[0].split('-').forEach(function(e) {\n+      var values = e.split('|');\n+      header[values[1]] = String.fromCharCode(values[0]);\n+    });\n+    var result = '';\n+    while (data.length) {\n+      var i = 0,\n+          cur = '';\n+      while (data.length) {\n+        cur += data.shift();\n+        if (header.hasOwnProperty(cur)) {\n+          result += header[cur];\n+          break;\n+        }\n+      }\n+    }\n+    return result;\n+  }\n+};\n\\ No newline at end of file""}","['Something is wrong with formatting here :thinking: ', 'okay! I think it is better to use the arrow function.\r\nThank you! 😄']"
27,268,open,"This solution makes the recursive approach possible by storing computed results and uses some good functional and advanced concepts. I'm still new to GitHub, this is in fact my first PR ever, so sorry if there are mistakes.",2,"['src/algorithms/math/fibonacci/README-recursive.md', 'src/algorithms/math/fibonacci/fibonacciRecursiveMemoized.js']",5,"['Add recursive Fibonacci function using memoization', ""Add README-recursive.md explaining code\n\nThere's already a README.md file in the folder so I couldn't come up with a better name, this is of course subject to change."", 'minor formatting changes', 'removed trailing spaces', ""Merge branch 'master' into patch-1""]","{'Name': 'src/algorithms/math/fibonacci/fibonacciRecursiveMemoized.js', 'Line Additions': 21, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,21 @@\n+/*  memoize function use a Map to store function arguments \n+and results, which are returned if found inside cache */\n+const memoize = (fn) => {\n+  const cache = new Map();\n+\n+  return (num) => {\n+    if (cache.has(num)) return cache.get(num);\n+\n+    const result = fn(num);\n+    cache.set(num, result);\n+    return result;\n+  };\n+};\n+\n+/*  fibonacci function decorated with the memoize function, every call \n+will first pass through the cache before it's computed  */\n+const fibonacci = memoize((n) => {\n+  if (n === 0 || n === 1) return n;\n+\n+  return fibonacci(n - 1) + fibonacci(n - 2);\n+});""}",[]
28,269,open,"[Persistent vector](https://github.com/trekhleb/javascript-algorithms/issues/216) uses a bit manipulation technique called [bit partitioning](http://www.hypirion.com/musings/understanding-persistent-vector-pt-2) to find a index in an array. I think it is best to understand this before moving onto the details of a persistent vector.
",3,"['src/algorithms/math/bits/README.md', 'src/algorithms/math/bits/__test__/bitPartition.test.js', 'src/algorithms/math/bits/bitPartition.js']",1,['Add bit partitioning'],"{'Name': 'src/algorithms/math/bits/bitPartition.js', 'Line Additions': 32, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,32 @@\n+/**\n+ * Return the number represented in a base which is a power of 2\n+ * For example given x >= 0, it can be rewritten in base 2 ** k as:\n+ * x = xn * ((2 ** k) ** n) + ... + x0 * ((2 ** k) ** 0)\n+ *   where\n+ *     0 <= xn, ... , x0 <= (2 ** k) - 1\n+ *     x < (2 ** k) ** (n + 1)\n+ *\n+ * @param {number} number\n+ * @param {number} number\n+ * @return {number[]}\n+ */\n+\n+export default function bitPartition(num, bits) {\n+  const mask = (1 << bits) - 1;\n+\n+  // find shift\n+  // where\n+  //   shift = n * bits\n+  //   num < (2 ** bits) ** (n + 1)\n+  let n = 0;\n+  while (num >= (2 ** bits) ** (n + 1)) {\n+    n += 1;\n+  }\n+\n+  const xs = [];\n+  for (let shift = bits * n; shift >= 0; shift -= bits) {\n+    xs.push((num >>> shift) & mask);\n+  }\n+\n+  return xs;\n+}'}",[]
29,270,open,"**##Description**
This PR adds a simple and  optimized solution for finding the Nth fibonacci problem, using backtracking in dynamic programming and other concepts like memoization and closures.

**##Time complexity:**
Best case :  O(1) 
Worst case : O(n)
",3,"['src/algorithms/math/fibonacci/README.md', 'src/algorithms/math/fibonacci/__test__/fibonacciNthBackTracking.test.js', 'src/algorithms/math/fibonacci/fibonacciNthBackTracking.js']",5,"['Added optimized solution for fibonacciNth problem', ""Merge branch 'master' into fibonacci"", ""Merge branch 'master' into fibonacci"", ""Merge branch 'master' into fibonacci"", ""Merge branch 'master' into fibonacci""]","{'Name': 'src/algorithms/math/fibonacci/fibonacciNthBackTracking.js', 'Line Additions': 36, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,36 @@\n+/**\n+ * Calculate fibonacci number at specific position using BackTracking approach\n+ * and concepts of memoization/closures.\n+ * The function doesn't backtrack values when it is cached in memoized\n+ * array,otherwise it does backtracking and stores in memoized array.\n+ * This way,execution of function query takes O(1) in best case and\n+ * O(n) in worst case\n+ *\n+ * @param n\n+ * @return {number}\n+ */\n+const fibonacciNth = () => {\n+  // memoized array for storing calculated values,this acts as a closure for inner function\n+  const memoized = [];\n+  return (n) => {\n+    // First two numbers in fibonacci series is 0 and 1\n+    memoized[0] = 0;\n+    memoized[1] = 1;\n+\n+    // When the memoized value is present return immediately in O(1)\n+    if (memoized[n] !== undefined) return memoized[n];\n+\n+    // When not present backtrack, calculate, store the results for all elements < n in O(n)\n+    let count;\n+    for (count = 2; count <= n; count += 1) {\n+      // for each number add the (count-1) and (count-2) and store in memoized array till we reach n\n+      memoized[count] = memoized[count - 1] + memoized[count - 2];\n+    }\n+\n+    // return the calculated result\n+    return memoized[n];\n+  };\n+};\n+const getFibonacci = fibonacciNth();\n+\n+export default getFibonacci;""}",[]
30,280,open,"Time complexity of a Bloom filter is on the order of the number of independent hash functions, `k`, not constant time.  ",1,['src/data-structures/bloom-filter/README.md'],2,"['Fix performance of bloom filter operations.\n\nPerformance of a bloom filter is on the order of the number of independent hash functions, k, not constant time.', ""Merge branch 'master' into master""]","{'Name': 'src/data-structures/bloom-filter/README.md', 'Line Additions': 1, 'Line Deletions': 1, 'Patch': '@@ -44,7 +44,7 @@ In other words, the filter can take in items. When\n we go to check if an item has previously been\n inserted, it can tell us either ""no"" or ""maybe"".\n \n-Both insertion and search are `O(1)` operations.\n+Both insertion and search are `O(k)` operations.\n \n ## Making the filter\n '}",[]
31,288,open,"If you like it, feel free to merge it :)",1,['README.md'],1,['Adding a Visualization'],"{'Name': 'README.md', 'Line Additions': 9, 'Line Deletions': 0, 'Patch': '@@ -300,3 +300,12 @@ Below is the list of some of the most used Big O notations and their performance\n | **Shell sort**        | n&nbsp;log(n)   | depends on gap sequence   | n&nbsp;(log(n))<sup>2</sup>  | 1         | No         |           |\n | **Counting sort**     | n + r           | n + r               | n + r               | n + r     | Yes       | r - biggest number in array |\n | **Radix sort**        | n * k           | n * k               | n * k               | n + k     | Yes       | k - length of longest key |\n+\n+### Code Visualization:\n+\n+Here is a cool visualization of the code evolution\n+\n+ [![Watch the video](https://img.youtube.com/vi/sQnIGCYU2F4/0.jpg)](https://www.youtube.com/watch?v=sQnIGCYU2F4)\n+\n+ [https://www.youtube.com/watch?v=sQnIGCYU2F4](https://www.youtube.com/watch?v=sQnIGCYU2F4)\n+'}",[]
32,289,open,,12,"['src/data-structures/tree/README.md', 'src/data-structures/tree/README.ru-RU.md', 'src/data-structures/tree/avl-tree/README.md', 'src/data-structures/tree/avl-tree/README.ru-RU.md', 'src/data-structures/tree/binary-search-tree/README.md', 'src/data-structures/tree/binary-search-tree/README.ru-RU.md', 'src/data-structures/tree/fenwick-tree/README.md', 'src/data-structures/tree/fenwick-tree/README.ru-RU.md', 'src/data-structures/tree/red-black-tree/README.md', 'src/data-structures/tree/red-black-tree/README.ru-RU.md', 'src/data-structures/tree/segment-tree/README.md', 'src/data-structures/tree/segment-tree/README.ru-RU.md']",11,"['Translate general Tree into Russian.', 'Translate Binary Search Tree into Russian.', 'Translate AVL Tree into Russian.', ""Merge branch 'master' into feature/translate-tree"", 'Update AVL-tree links. Translate complexity table headers.', ""Merge branch 'feature/translate-tree' of github.com:kinospro/javascript-algorithms into feature/translate-tree"", 'Update AVL-tree description.', 'Translate Fenwick Tree.', 'Translate Red Black Tree.', 'Translate Segment Tree into Russian. Fix typo in English README.', ""Merge branch 'master' into feature/translate-tree""]","{'Name': 'src/data-structures/tree/segment-tree/README.ru-RU.md', 'Line Additions': 36, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,36 @@\n+# Дерево отрезков\n+\n+В информатике **дерево отрезков**  это древовидная структура, используемая для хранения\n+информации об отрезках и интервалах. Она позволяет выяснить какой из сегментов содержит\n+заданную точку. По сути это статичная структура; т.е. структура, которая не меняется\n+после создания. Схожей структурой является дерево интервалов.\n+\n+Дерево отрезков являет собой бинарное дерево. Корень дерева представляет целый массив.\n+Два потомка корня представляют первую и вторую половины массива. Похожим образом, потомки\n+каждого узла соответствуют двум половинам массива, соответствующего данному узлу.\n+\n+Мы строим дерево вверх ногами, где значение каждого узла является ""минимальным"" (или\n+может быть выражено любой другой функцией) из своих узлов-потомков. Это потребует\n+`O(n log n)` времени. Количество выполненных операций равно высоте дерева, т.е. `O(log n)`.\n+Для выполнения запроса на отрезке каждый узел делит запрос на две части - по одному подзапросу\n+на каждого потомка. Если запрос содержит целый подмассив узла, мы можем использовать\n+предварительно вычисленное значение узла. Пользуясь данной оптимизацией можно доказать,\n+что было выполнено только `O(log n)` вычислений минимума.\n+\n+## Применение\n+\n+Дерево отрезков спроектировано для эффективного выполнения определённых операций над\n+массивами - особенно тех, которые включают запрос на отрезке.\n+\n+Применения дерева отрезков сосредоточены в области вычислительной геометрии и географических\n+информационных систем.\n+\n+Приведённая реализация дерева отрезков подразумевает, что вы можете передать любую бинарную\n+операцию (над двумя выходными параметрами). Т.о. вы имеете возможность выполнить запрос на\n+отрезке для самых разных функций. В тестах вы можете найти примеры выполнения `min`, `max`\n+и `sum` на дереве отрезков.\n+\n+## Ссылки\n+\n+- [Wikipedia](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%BE%D0%B2)\n+- [YouTube](https://www.youtube.com/watch?v=Y_KJaF9bIbY)'}",[]
33,292,open,,1,['src/data-structures/linked-list/README.md'],3,"[""Added simple 'Snake Game' example"", 'Added examples for linked list README', 'Fixed typo']","{'Name': 'src/data-structures/linked-list/README.md', 'Line Additions': 69, 'Line Deletions': 0, 'Patch': ""@@ -154,6 +154,75 @@ end ReverseTraversal\n \n O(n)\n \n+\n+### Examples\n+Some of real live usages are listed below:\n+\n+  - Snake Game\n+    You start the game with one node on the list which in thime and place is both the head and tail\n+\n+      [] <- (single node)\n+\n+    As the snake keeps eating those items are being added to the tail, and as such, becoming the tail for the list\n+\n+     (food)-> *  [] <-(snake)\n+                /  \\ \n+              head tail\n+\n+        [][] (snake has eaten and it grew by one)\n+        /  \\\n+      head tail\n+\n+    And so on and so forth\n+      (food)-> *  [][] <-(snake)\n+                  /   \\ \n+                head  tail\n+\n+          [][][] (snake has eaten and it grew by one)\n+          /     \\\n+        head   tail\n+\n+\n+\n+      (food)-> *  [][][] <-(snake)\n+                  /     \\ \n+                head    tail\n+\n+          [][][][] (snake has eaten and it grew by one)\n+          /       \\\n+        head     tail\n+\n+\n+ - Web Browser History\n+    Let's say you are confortably browsing the web on your computer, you are using your favorite browser, when you visit your first page your browser creates a single node list with the website you are looking at.\n+\n+    The value for the node would then be the link for that site, for example, Github\n+\n+            [ Github/javascript-algorithms ].  <- current website (tail and also head)\n+\n+    But then you decide to go to facebook on that tab, but your browser instead of forgetting where you've been keeps track of the last page by adding nodes to that list\n+\n+            [ Github/javascript-algorithms ].  <- (head)\n+                        |\n+            [ Facebook/your-profile  ] <- current website (tail)\n+\n+    As you keep visiting new websites on that tab the browser keeps track of it and will append it to the tail of the list\n+    until you have something like this\n+\n+            [ Github/javascript-algorithms ].  <- (head)\n+                        |\n+            [ Facebook/your-profile  ] <- node\n+                        |\n+            [ Wikipedia/Pomodoro_Technique ] <- node\n+                        |\n+            [ Wikipedia/Life_hack ] <- node\n+                        |\n+            [ Whatsapp ] <- current website (tail)\n+\n+    This is a very good example of a double link list\n+\n+\n+ \n ## References\n \n - [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)""}",[]
34,294,open,,4,"['package-lock.json', 'src/algorithms/sorting/bucket-sort/BucketSort.js', 'src/algorithms/sorting/bucket-sort/README.md', 'src/algorithms/sorting/bucket-sort/_test_/BucketSort.test.js']",1,['Added a bucket sort #206'],"{'Name': 'src/algorithms/sorting/bucket-sort/_test_/BucketSort.test.js', 'Line Additions': 15, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,15 @@\n+import BucketSort from '../BucketSort';\n+import {\n+  SortTester,\n+} from '../../SortTester';\n+\n+\n+describe('BucketSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(BucketSort);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(BucketSort);\n+  });\n+});""}",[]
35,298,open,I find a new method to solve merge sort problem while reading [Data Structures and Algorithms with JavaScript](http://shop.oreilly.com/product/0636920029557.do). It can avoid stack overflow when originalArray is too large. I have made some changes to make it conform to the ES6 specification. I think it's meaningful to share it. :blush:,2,"['src/algorithms/sorting/merge-sort/MergeSortWithoutRecursion.js', 'src/algorithms/sorting/merge-sort/__test__/MergeSortWithoutRecursion.test.js']",2,"['add new mergesort method without recursion', '[fix] replace CRLF with LF']","{'Name': 'src/algorithms/sorting/merge-sort/__test__/MergeSortWithoutRecursion.test.js', 'Line Additions': 66, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,66 @@\n+import MergeSortWithoutRecursion from '../MergeSort';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+const SORTED_ARRAY_VISITING_COUNT = 79;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 102;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 87;\n+const EQUAL_ARRAY_VISITING_COUNT = 79;\n+\n+const MergeSort = MergeSortWithoutRecursion;\n+\n+describe('MergeSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(MergeSort);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(MergeSort);\n+  });\n+\n+  it('should do stable sorting', () => {\n+    SortTester.testSortStability(MergeSort);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(MergeSort);\n+  });\n+\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      MergeSort,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      MergeSort,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      MergeSort,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      MergeSort,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+});""}",[]
36,300,open,"according to my test, pop is faster than shift, especially when the array is very long.",1,['src/algorithms/sorting/quick-sort/QuickSort.js'],3,"['switch shift to pop\n\naccording to my test, pop is faster than shift, especially when the array is very long.', ""Merge branch 'master' into master"", ""Merge branch 'master' into master""]","{'Name': 'src/algorithms/sorting/quick-sort/QuickSort.js', 'Line Additions': 2, 'Line Deletions': 2, 'Patch': '@@ -19,12 +19,12 @@ export default class QuickSort extends Sort {\n     const rightArray = [];\n \n     // Take the first element of array as a pivot.\n-    const pivotElement = array.shift();\n+    const pivotElement = array.pop();\n     const centerArray = [pivotElement];\n \n     // Split all array elements between left, center and right arrays.\n     while (array.length) {\n-      const currentElement = array.shift();\n+      const currentElement = array.pop();\n \n       // Call visiting callback.\n       this.callbacks.visitingCallback(currentElement);'}","['shift and pop are used for different purposes. shift removes element from the front of the array and pop removes from the end. hence pop cannot used to get the first element in the array.', 'in this sutiation, it can work well no matter the element is taken from the front of the array or the end', '@chandrunaik and @mrbeannnnn , in this case pop is better than shift because pop is O(1) (constant operation) where as shift() is O(n) .', 'quick-sort should work well not metter the element is get from the top or from the end.\r\nwhile in JS, pop is faster than shift, as talentedandrew said above.\r\nso I think pop is better here.']"
37,304,open,"**Details:**

This Pull Request fixes bugs related to unicode support in polynomial-hash functions:
- Method `charToNumber` of `PolynomialHash` was wrongly computed the code point value of a character: `codePointAt` is already aware of surrogate pairs (which is not the case of `charCodeAt`)
- Method `roll` of `PolynomialHash` ignored unicode characters totally
- `SimplePolynomialHash` was not aware of unicode

**How did I find it?**

Originally I wanted to check how I could rewrite the existing for-loop based tests into something based on property based. Then it clearly appeared that the test can be simplified given the switch to property based: `roll(hash(XYZ), XYZ, YZA) === hash(YZA)` whatever the values of `X`, `Y`, `Z`, `A`.

The final version of the test can be read as follow:
For any `A` single character, `B` single character and `W` string,
`roll(hash(A + W), A + W, W + B) === hash(W + B)`

As a side note, I strongly believe that adding such kind of tests would highly help to detect such bugs easily. Up to now it has detected the following: #100, #101, #102, #110 and #129.

And also #305, #306, #307, #308.",6,"['package-lock.json', 'package.json', 'src/algorithms/cryptography/polynomial-hash/PolynomialHash.js', 'src/algorithms/cryptography/polynomial-hash/SimplePolynomialHash.js', 'src/algorithms/cryptography/polynomial-hash/__test__/PolynomialHash.test.js', 'src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js']",6,"['Fix eslint on pre-commit', 'Switch to property based for PolynomialHash', 'Simplify test for PolynomialHash.roll', 'Add support for unicode strings in SimplePolynomialHash', 'Add support for unicode in PolynomialHash.roll', ""Merge branch 'master' into polynomial""]","{'Name': 'src/algorithms/cryptography/polynomial-hash/__test__/SimplePolynomialHash.test.js', 'Line Additions': 18, 'Line Deletions': 28, 'Patch': ""@@ -1,40 +1,30 @@\n+import fc from 'fast-check';\n import SimplePolynomialHash from '../SimplePolynomialHash';\n \n-describe('PolynomialHash', () => {\n+describe('SimplePolynomialHash', () => {\n   it('should calculate new hash based on previous one', () => {\n-    const bases = [3, 5];\n-    const frameSizes = [5, 10];\n+    fc.assert(\n+      fc.property(\n+        fc.constantFrom(3, 79, 101, 3251, 13229, 122743, 3583213),\n+        fc.fullUnicodeString(0, 50),\n+        fc.fullUnicode(),\n+        fc.fullUnicode(),\n+        (base, commonWord, previousChar, newChar) => {\n+          fc.pre(0xffff * (base ** commonWord.length) < 0x7fffffff); // avoid overflows\n+\n+          const polynomialHash = new SimplePolynomialHash(base);\n+          const previousWord = previousChar + commonWord;\n+          const currentWord = commonWord + newChar;\n+          const previousHash = polynomialHash.hash(previousWord);\n \n-    const text = 'Lorem Ipsum is simply dummy text of the printing and '\n-      + 'typesetting industry. Lorem Ipsum has been the industry\\'s standard '\n-      + 'galley of type and \\u{ffff} scrambled it to make a type specimen book. It '\n-      + 'electronic 耀 typesetting, remaining essentially unchanged. It was '\n-      + 'popularised in the 1960s with the release of Letraset sheets '\n-      + 'publishing software like Aldus 耀 PageMaker including versions of Lorem.';\n-\n-    // Check hashing for different prime base.\n-    bases.forEach((base) => {\n-      const polynomialHash = new SimplePolynomialHash(base);\n-\n-      // Check hashing for different word lengths.\n-      frameSizes.forEach((frameSize) => {\n-        let previousWord = text.substr(0, frameSize);\n-        let previousHash = polynomialHash.hash(previousWord);\n-\n-        // Shift frame through the whole text.\n-        for (let frameShift = 1; frameShift < (text.length - frameSize); frameShift += 1) {\n-          const currentWord = text.substr(frameShift, frameSize);\n           const currentHash = polynomialHash.hash(currentWord);\n           const currentRollingHash = polynomialHash.roll(previousHash, previousWord, currentWord);\n \n           // Check that rolling hash is the same as directly calculated hash.\n           expect(currentRollingHash).toBe(currentHash);\n-\n-          previousWord = currentWord;\n-          previousHash = currentHash;\n-        }\n-      });\n-    });\n+        },\n+      ),\n+    );\n   });\n \n   it('should generate numeric hashed', () => {""}",[]
38,329,open,Fix issue #325,2,"['src/data-structures/tree/avl-tree/AvlTree.js', 'src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js']",1,['Fix Bug in AVL Tree rorateLeftLeft and rotateRightRight'],"{'Name': 'src/data-structures/tree/avl-tree/__test__/AvlTRee.test.js', 'Line Additions': 17, 'Line Deletions': 0, 'Patch': ""@@ -230,6 +230,23 @@ describe('AvlTree', () => {\n     expect(tree.root.height).toBe(3);\n   });\n \n+  it('should do right right rotation and keeping left node safe', () => {\n+    const tree = new AvlTree();\n+    tree.insert(24);\n+    tree.insert(12);\n+    tree.insert(34);\n+    tree.insert(15);\n+\n+    expect(tree.toString()).toBe('12,15,24,34');\n+\n+    tree.insert(18);\n+    expect(tree.toString()).toBe('12,15,18,24,34');\n+    expect(tree.root.height).toBe(2);\n+    expect(tree.root.left.value).toBe(15);\n+    expect(tree.root.left.left.value).toBe(12);\n+    expect(tree.root.left.right.value).toBe(18);\n+  });\n+\n   it('should remove values from the tree with right-right rotation', () => {\n     const tree = new AvlTree();\n ""}",[]
39,341,open,"Rearrange description, fix typos",1,['src/data-structures/bloom-filter/README.ru-RU.md'],1,"['Bloom filter, RU, change description\n\nRearrange description, fix typos']","{'Name': 'src/data-structures/bloom-filter/README.ru-RU.md', 'Line Additions': 11, 'Line Deletions': 11, 'Patch': '@@ -12,30 +12,30 @@\n \n ## Описание алгоритма\n \n-Пустой фильтр Блума представлен битовым массивом из `m` битов, все биты которого обнулены. Должно быть определено `k`\n-независимых хеш-функций, отображающих каждый элемент множества в одну из `m` позиций в массиве, генерируя единообразное\n-случайное распределение. Обычно `k` задана константой, которая много меньше `m` и пропорциональна\n-количеству добавляемых элементов; точный выбор `k` и постоянной пропорциональности `m` определяются уровнем ложных\n-срабатываний фильтра.\n-\n-Вот пример Блум фильтра, представляющего набор `{x, y, z}`. Цветные стрелки показывают позиции в битовом массиве,\n-которым привязан каждый элемент набора. Элемент `w` не в набора `{x, y, z}`, потому что он привязан к позиции в битовом\n-массиве, равной `0`. Для этой формы , `m = 18`, а `k = 3`.\n-\n Фильтр Блума представляет собой битовый массив из `m` бит. Изначально, когда структура данных хранит пустое множество, все\n `m` бит обнулены. Пользователь должен определить `k` независимых хеш-функций `h1`, …, `hk`,\n отображающих каждый элемент в одну из `m` позиций битового массива достаточно равномерным образом.\n+Обычно `k` задана константой, которая много меньше `m` и пропорциональна\n+количеству добавляемых элементов; точный выбор `k` и постоянной пропорциональности `m` определяются уровнем ложных\n+срабатываний фильтра.\n \n Для добавления элемента e необходимо записать единицы на каждую из позиций `h1(e)`, …, `hk(e)`\n битового массива.\n \n+\n Для проверки принадлежности элемента `e` к множеству хранимых элементов, необходимо проверить состояние битов\n `h1(e)`, …, `hk(e)`. Если хотя бы один из них равен нулю, элемент не может принадлежать множеству\n (иначе бы при его добавлении все эти биты были установлены). Если все они равны единице, то структура данных сообщает,\n-что `е` принадлежит множеству. При этом может возникнуть две ситуации: либо элемент действительно принадлежит множеству,\n+что `е`, *возможно*, принадлежит множеству. При этом может возникнуть две ситуации: либо элемент действительно принадлежит множеству,\n либо все эти биты оказались установлены по случайности при добавлении других элементов, что и является источником ложных\n срабатываний в этой структуре данных.\n \n+\n+Вот пример Блум фильтра, представляющего набор `{x, y, z}`. Цветные стрелки показывают позиции в битовом массиве,\n+к которым привязан каждый элемент набора. Элемент `w` не в наборе `{x, y, z}`, потому что он привязан к позиции в битовом\n+массиве, равной `0`. Для этой формы , `m = 18`, а `k = 3`.\n+\n+\n ![Фильтр Блума](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)\n \n ## Применения'}",[]
40,343,open,implemented the Fibonacci Search Algorithm,3,"['src/algorithms/search/README.md', 'src/algorithms/search/fibonacci-search/__test__/fibonacciSearch.js', 'src/algorithms/search/fibonacci-search/fibonacciSearch.js']",1,['Fibonacci Search \n\nimplemented the Fibonacci Search Algorithm'],"{'Name': 'src/algorithms/search/fibonacci-search/fibonacciSearch.js', 'Line Additions': 69, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,69 @@\n+/** Author Slim Gharbi\n+ * Fibonacci search implementation.\n+ *\n+ * @param {*[]} integers\n+ * @param {*} elementToSearch\n+ * @return {number}\n+ */\n+\n+\n+export default function fibonacciSearch(integers,elementToSearch) {\n+    /* Initialize fibonacci numbers */\n+    fibonacciMinus2 = 0;   // (m-2)'th Fibonacci No. \n+    fibonacciMinus1 = 1;   // (m-1)'th Fibonacci No. \n+    fibonacciNumber = fibonacciMinus2 + fibonacciMinus1; // m'th Fibonacci \n+  \n+\n+    /* fibonacciNumber is going to store the smallest  \n+    Fibonacci Number greater than or equal to the length of the array */\n+   while (fibonacciNumber < integers.length) {\n+       fibonacciMinus2 = fibonacciMinus1;\n+       fibonacciMinus1 = fibonacciNumber;\n+       fibonacciNumber = fibonacciMinus2 + fibonacciMinus1;\n+   }\n+\n+    // Marks the eliminated range from front \n+    offset = -1;\n+\n+    /* while there are elements to be inspected.  \n+       Note that we compare integers[fibonacciMinus2] with elementToSearch.  \n+       When fibonacciNumber becomes 1, fibonacciMinus2 becomes 0 */\n+   while (fibonacciNumber > 1) {\n+\n+       // Check if fibonacciMinus2 is a valid location \n+       i = Math.min(offset+fibonacciMinus2, integers.length-1);\n+\n+       /* If elementToSearch is greater than the value at  \n+          index fibonacciMinus2, cut the subarray array  \n+          from offset to i */\n+       if (integers[i] < elementToSearch) {\n+           fibonacciNumber = fibonacciMinus1;\n+           fibonacciMinus1 = fibonacciMinus2;\n+           fibonacciMinus2 = fibonacciNumber - fibonacciMinus1;\n+           offset = i;\n+       }\n+\n+       /* If elementToSearch is greater than the value at index  \n+          fibonacciMinus2, cut the subarray after i+1 */\n+       else if (integers[i] > elementToSearch) {\n+           fibonacciNumber = fibonacciMinus2;\n+           fibonacciMinus1 = fibonacciMinus1 - fibonacciMinus2;\n+           fibonacciMinus2 = fibonacciNumber - fibonacciMinus1;\n+       }\n+        /* element found. return index */\n+        else return i;\n+   }\n+   /* comparing the last element with elementToSearch */\n+   if (fibonacciMinus1 == 1 && integers[offset+1] == elementToSearch)\n+       return offset+1;\n+   /*element not found. return -1 */\n+   return -1;\n+}\n+\n+\n+\n+\n+\n+\n+\n+""}",[]
41,347,open,"I was investigating how Knapsack 0/1 algorithm is implemented and noticed that there is a bug.

What was done:
1. I've added test-case(please see the change), which shows that there is a problem.
This test case resulted in ""solveZeroOneKnapsackProblem"" method throwing an exception:
![2019-04-25_14-09-59](https://user-images.githubusercontent.com/12975069/56731985-9bcffb00-6764-11e9-9e97-878c7035d8e1.png)

2. Fixed the ""tracing up"" part of Knapsack 0/1 algorithm to fix the problem.
Made sure that all previous tests also pass(and ESLint is fine too).",2,"['src/algorithms/sets/knapsack-problem/Knapsack.js', 'src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js']",1,"['Add test for Knapsack 0/1 problem and fix ""tracing"" part of this algorithm.']","{'Name': 'src/algorithms/sets/knapsack-problem/__test__/Knapsack.test.js', 'Line Additions': 20, 'Line Deletions': 0, 'Patch': ""@@ -44,6 +44,26 @@ describe('Knapsack', () => {\n     expect(knapsack.selectedItems[1].toString()).toBe('v4 w3 x 1');\n   });\n \n+  it('should solve 0/1 knapsack problem 2', () => {\n+    const possibleKnapsackItems = [\n+      new KnapsackItem({ value: 5, weight: 3 }),\n+      new KnapsackItem({ value: 3, weight: 2 }),\n+      new KnapsackItem({ value: 4, weight: 1 }),\n+    ];\n+\n+    const maxKnapsackWeight = 5;\n+\n+    const knapsack = new Knapsack(possibleKnapsackItems, maxKnapsackWeight);\n+\n+    knapsack.solveZeroOneKnapsackProblem();\n+\n+    expect(knapsack.totalValue).toBe(9);\n+    expect(knapsack.totalWeight).toBe(4);\n+    expect(knapsack.selectedItems.length).toBe(2);\n+    expect(knapsack.selectedItems[0].toString()).toBe('v5 w3 x 1');\n+    expect(knapsack.selectedItems[1].toString()).toBe('v4 w1 x 1');\n+  });\n+\n   it('should solve 0/1 knapsack problem with impossible items set', () => {\n     const possibleKnapsackItems = [\n       new KnapsackItem({ value: 5, weight: 40 }),""}",[]
42,348,open,implemented fibonacci search with its test,3,"['src/algorithms/search/fibonacci-search/README.md', 'src/algorithms/search/fibonacci-search/__test__/fibonacciSearch.test.js', 'src/algorithms/search/fibonacci-search/fibonacciSearch.js']",1,['Add the Fibonacci Search Algortihm\n\nimplemented fibonacci search with its test'],"{'Name': 'src/algorithms/search/fibonacci-search/fibonacciSearch.js', 'Line Additions': 51, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,51 @@\n+/** Author Slim Gharbi\n+ * Fibonacci search implementation.\n+ *\n+ * @param {*[]} integers\n+ * @param {*} elementToSearch\n+ * @return {number}\n+ */\n+export default function fibonacciSearch(integers, elementToSearch) {\n+  let i;\n+\n+  /* Initialize fibonacci numbers */\n+  let fibonacciMinus2 = 0;// (m-2)'th Fibonacci No.\n+  let fibonacciMinus1 = 1;// (m-1)'th Fibonacci No.\n+  let fibonacciNumber = fibonacciMinus2 + fibonacciMinus1; // m'th Fibonacci\n+  /* fibonacciNumber is going to store the smallest\n+ Fibonacci Number greater than or equal to the length of the array */\n+  while (fibonacciNumber < integers.length) {\n+    fibonacciMinus2 = fibonacciMinus1;\n+    fibonacciMinus1 = fibonacciNumber;\n+    fibonacciNumber = fibonacciMinus2 + fibonacciMinus1;\n+  }\n+  // Marks the eliminated range from front\n+  let offset = -1;\n+  /* while there are elements to be inspected.\n+ Note that we compare integers[fibonacciMinus2] with elementToSearch.\n+ When fibonacciNumber becomes 1, fibonacciMinus2 becomes 0 */\n+  while (fibonacciNumber > 1) {\n+  // Check if fibonacciMinus2 is a valid location\n+    i = Math.min((offset + fibonacciMinus2), (integers.length - 1));\n+    /* If elementToSearch is greater than the value at\n+  index fibonacciMinus2, cut the subarray array\n+  from offset to i */\n+    if (integers[i] < elementToSearch) {\n+      fibonacciNumber = fibonacciMinus1;\n+      fibonacciMinus1 = fibonacciMinus2;\n+      fibonacciMinus2 = fibonacciNumber - fibonacciMinus1;\n+      offset = i;\n+    } else if (integers[i] > elementToSearch) {\n+      fibonacciNumber = fibonacciMinus2;\n+      fibonacciMinus1 -= fibonacciMinus2;\n+      fibonacciMinus2 = fibonacciNumber - fibonacciMinus1;\n+      /* If elementToSearch is greater than the value at index\n+      fibonacciMinus2, cut the subarray after i+1 */\n+    } else return i;\n+    // element found. return index\n+  }\n+  // comparing the last element with elementToSearch\n+  if (fibonacciMinus1 === 1 && integers[offset + 1] === elementToSearch) return offset + 1;\n+  // element not found. return -1\n+  return -1;\n+}""}",[]
43,356,open,Removed tmp const and swapped elements using destructuring,1,['src/algorithms/sorting/insertion-sort/InsertionSort.js'],3,"['Optimized removing tmp const\n\nRemoved tmp const and swapped elements using destructuring', 'Added semicolon and resolved max-len for a line', 'Update InsertionSort.js']","{'Name': 'src/algorithms/sorting/insertion-sort/InsertionSort.js', 'Line Additions': 4, 'Line Deletions': 3, 'Patch': '@@ -21,9 +21,10 @@ export default class InsertionSort extends Sort {\n         this.callbacks.visitingCallback(array[currentIndex - 1]);\n \n         // Swap the elements.\n-        const tmp = array[currentIndex - 1];\n-        array[currentIndex - 1] = array[currentIndex];\n-        array[currentIndex] = tmp;\n+        [\n+          array[currentIndex - 1],\n+          array[currentIndex],\n+        ] = [array[currentIndex], array[currentIndex - 1]];\n \n         // Shift current index left.\n         currentIndex -= 1;'}",[]
44,359,open,The lcsMatrix creation can be optimized.,1,['src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js'],1,['longestCommonSubsequence optimization\n\nThe lcsMatrix creation can be optimized.'],"{'Name': 'src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js', 'Line Additions': 2, 'Line Deletions': 12, 'Patch': '@@ -5,18 +5,8 @@\n  */\n export default function longestCommonSubsequence(set1, set2) {\n   // Init LCS matrix.\n-  const lcsMatrix = Array(set2.length + 1).fill(null).map(() => Array(set1.length + 1).fill(null));\n-\n-  // Fill first row with zeros.\n-  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n-    lcsMatrix[0][columnIndex] = 0;\n-  }\n-\n-  // Fill first column with zeros.\n-  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n-    lcsMatrix[rowIndex][0] = 0;\n-  }\n-\n+  const lcsMatrix = Array(set2.length + 1).fill().map(() => Array(set1.length + 1).fill().map(() => 0));\n+  \n   // Fill rest of the column that correspond to each of two strings.\n   for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n     for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {'}",[]
45,362,open,"Hello,

I would like to contribute my favourite sorting algorithms. It's not very effective, but it is very easy to understand.

@trekhleb Can I still do something for this project? 

Thanks",2,"['src/algorithms/sorting/quick-sort/QuickSortDeclarative.js', 'src/algorithms/sorting/quick-sort/__test__/QuickSortDeclarative.test.js']",1,['Add declarative version of quick sort'],"{'Name': 'src/algorithms/sorting/quick-sort/__test__/QuickSortDeclarative.test.js', 'Line Additions': 60, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,60 @@\n+import QuickSortDeclarative from '../QuickSortDeclarative';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+const SORTED_ARRAY_VISITING_COUNT = 20;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 20;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 20;\n+const EQUAL_ARRAY_VISITING_COUNT = 20;\n+\n+describe('QuickSortDeclarative', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(QuickSortDeclarative);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(QuickSortDeclarative);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(QuickSortDeclarative);\n+  });\n+\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortDeclarative,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortDeclarative,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortDeclarative,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      QuickSortDeclarative,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+});""}",[]
46,363,open,,2,"['src/algorithms/sets/cartesian-product/__test__/cartesianProduct.test.js', 'src/algorithms/sets/cartesian-product/cartesianProduct.js']",2,"['fix: return empty set when either is empty', 'test cartesian product']","{'Name': 'src/algorithms/sets/cartesian-product/cartesianProduct.js', 'Line Additions': 5, 'Line Deletions': 2, 'Patch': ""@@ -5,14 +5,17 @@\n  * @return {*[]}\n  */\n export default function cartesianProduct(setA, setB) {\n-  // Check if input sets are not empty.\n+  // Check if input sets are not non-arrays.\n   // Otherwise return null since we can't generate Cartesian Product out of them.\n-  if (!setA || !setB || !setA.length || !setB.length) {\n+  if (!setA || !setB) {\n     return null;\n   }\n \n   // Init product set.\n   const product = [];\n+  if (!setA.length || !setB.length) {\n+    return product;\n+  }\n \n   // Now, let's go through all elements of a first and second set and form all possible pairs.\n   for (let indexA = 0; indexA < setA.length; indexA += 1) {""}",[]
47,364,open,"リンクリストより連結リストの方が名称が一般的だと思われます。
The ""連結テスト"" seems to be more general than the ""リンクリスト"".
https://ja.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E3%83%AA%E3%82%B9%E3%83%88",1,['src/data-structures/linked-list/README.ja-JP.md'],1,['Update README.ja-JP.md\n\nリンクリストより連結リストの方が名称が一般的だと思われます。'],"{'Name': 'src/data-structures/linked-list/README.ja-JP.md', 'Line Additions': 2, 'Line Deletions': 2, 'Patch': '@@ -1,6 +1,6 @@\n-# リンクリスト\n+# 連結リスト\n \n-コンピュータサイエンスにおいて、**リンクリスト**はデータ要素の線形コレクションです。要素の順番はメモリ内の物理的な配置によっては決まりません。代わりに、各要素が次の要素を指しています。リンクリストはノードのグループからなるデータ構造です。最も単純な形式では、各ノードはデータとシーケンス内における次のノードへの参照(つまり、リンク)で構成されています。この構造はイテレーションにおいて任意の位置へ要素を効率的に挿入、削除することを可能にしています。より複雑なリンクリストではリンクをさらに追加することで、任意の要素の参照から要素を効率的に挿入、削除することを可能にしています。リンクリストの欠点はアクセスタイムが線形である(そして、パイプライン処理が難しい)ことです。ランダムアクセスのような高速なアクセスは実現不可能です。配列の方がリンクリストと比較して参照の局所性が優れています。\n+コンピュータサイエンスにおいて、**連結リスト**はデータ要素の線形コレクションです。要素の順番はメモリ内の物理的な配置によっては決まりません。代わりに、各要素が次の要素を指しています。連結リストはノードのグループからなるデータ構造です。最も単純な形式では、各ノードはデータとシーケンス内における次のノードへの参照(つまり、リンク)で構成されています。この構造はイテレーションにおいて任意の位置へ要素を効率的に挿入、削除することを可能にしています。より複雑な連結リストではリンクをさらに追加することで、任意の要素の参照から要素を効率的に挿入、削除することを可能にしています。リンクリストの欠点はアクセスタイムが線形である(そして、パイプライン処理が難しい)ことです。ランダムアクセスのような高速なアクセスは実現不可能です。配列の方が連結リストと比較して参照の局所性が優れています。\n \n ![Linked List](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n '}",[]
48,365,open,"In Japanese, the ""連結リスト"" seems to be more general than the ""リンクされたリスト"".
Furthermore,  the ""双方向リスト"" seems to be more general than the ""二重リンクリスト"".
https://ja.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E3%83%AA%E3%82%B9%E3%83%88",1,['README.ja-JP.md'],2,"['Update README.ja-JP.md\n\nIn Japanese, the ""連結リスト"" seems to be more general than the ""リンクリスト"".\r\nFurthermore,  the ""双方向リスト"" seems to be more general than the ""二重リンクリスト"".\r\nhttps://ja.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E3%83%AA%E3%82%B9%E3%83%88', ""Merge branch 'master' into patch-2""]","{'Name': 'README.ja-JP.md', 'Line Additions': 2, 'Line Deletions': 2, 'Patch': '@@ -28,8 +28,8 @@ _Read this in other languages:_\n \n `B` - 初心者, `A` - 上級\n \n-* `B` [リンクされたリスト](src/data-structures/linked-list)\n-* `B` [二重リンクリスト](src/data-structures/doubly-linked-list)\n+* `B` [連結リスト](src/data-structures/linked-list)\n+* `B` [双方向リスト](src/data-structures/doubly-linked-list)\n * `B` [キュー](src/data-structures/queue)\n * `B` [スタック](src/data-structures/stack)\n * `B` [ハッシュ表](src/data-structures/hash-table)'}",[]
49,366,open,【Add】 Longest non-repeating substring,3,"['src/algorithms/string/longest-non-repeating-substring/README.md', 'src/algorithms/string/longest-non-repeating-substring/__test__/longestNonRepeatingSubstring.test.js', 'src/algorithms/string/longest-non-repeating-substring/longestNonRepeatingSubstring.js']",2,"['longest-non-repeating-substring', 'longestNonRepeatingSubstring']","{'Name': 'src/algorithms/string/longest-non-repeating-substring/longestNonRepeatingSubstring.js', 'Line Additions': 26, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,26 @@\n+/**\n+ * 最长不重复子串\n+ * @param {*} s \n+ */\n+export default function lengthOfLongestSubstring(s) { \n+  if(!s){\n+      return 0;\n+  }\n+  let arr = s.split('');// 将s转换成字符数组\n+  let result = [];// 保存当前不重复字符\n+  let maxLength = 0;// 当前最大不重复字符\n+  arr.forEach(char => {\n+      let currentIndex = result.indexOf(char);\n+      result.push(char);\n+      if(currentIndex >= 0){\n+          // 如果出现重复字符，就截取该字符，保证result始终是不重复字符\n+          result = result.slice(currentIndex + 1);\n+      }\n+      if(maxLength < result.length){\n+          // 保存当前最长不重复字符\n+          maxLength = result.length\n+      }\n+  });\n+  \n+  return maxLength;\n+}\n\\ No newline at end of file""}",[]
50,368,open,,3,"['src/algorithms/uncategorized/luhn-algorithm/README.md', 'src/algorithms/uncategorized/luhn-algorithm/__test__/luhnAlgorithm.test.js', 'src/algorithms/uncategorized/luhn-algorithm/luhnAlgorithm.js']",3,"['Adding Luhn algorithm', ""Merge branch 'master' into luhn_algorithm"", ""Merge branch 'master' into luhn_algorithm""]","{'Name': 'src/algorithms/uncategorized/luhn-algorithm/luhnAlgorithm.js', 'Line Additions': 43, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,43 @@\n+/**\n+ * Returns true/false depending on input account number\n+ *\n+ * @param {string\\number} accountNumber\n+ * @return {boolean}\n+ */\n+export default function luhnAlgorithm(accountNumber) {\n+  // create two variables s1 and s2 for the odd digit and even digit sums.\n+  let s1 = 0;\n+  let s2 = 0;\n+\n+  // create variable to decrement accountNumber\n+  let accountNo = accountNumber;\n+\n+  // create flag to toggle between oddDigit and evenDigit\n+  let isOddDigit = true;\n+\n+\n+  while (accountNo > 0) {\n+    // use mod 10 to get next digit\n+    const nextDigit = accountNo % 10;\n+\n+    // decrease accountNo by dividing it by 10\n+    accountNo = Math.floor(accountNo / 10);\n+\n+    // if oddDigit, add nextDigit to s1\n+    if (isOddDigit) {\n+      s1 += nextDigit;\n+    } else {\n+      // else, double nextDigit\n+      const twiceDigit = nextDigit * 2;\n+\n+      // add the sum of twiceDigit's digits to s2\n+      s2 += (twiceDigit % 10) + Math.floor(twiceDigit / 10);\n+    }\n+\n+    // toggle isOddDigit flag\n+    isOddDigit = !isOddDigit;\n+  }\n+\n+  // if s1 + s2 mod 10 is 0, the accountNumber is valid\n+  return (s1 + s2) % 10 === 0;\n+}""}",[]
51,372,open,"Hi, good to see javascript data-structures and algorithms stacked at one place. So thought of contributing to it.
I added algorithms for conversion of a binary number to decimal number and vice versa in algorithms/math/binary directory. Let me know if it sounds good.",8,"['package.json', 'src/algorithms/math/binary/README.md', 'src/algorithms/math/binary/__test__/binaryToDecimal.test.js', 'src/algorithms/math/binary/__test__/decimalToBinary.test.js', 'src/algorithms/math/binary/binaryToDecimal.js', 'src/algorithms/math/binary/decimalToBinary.js', 'src/algorithms/math/binary/images/binaryToDecimal.PNG', 'src/algorithms/math/binary/images/decimalToBinary.PNG']",9,"['algorithms for conversion of binary number to decimal number and vice versa is added', 'Update README.md', 'Update README.md', 'errors updated', 'added more test cases', 'test cases changed', 'added more test cases', 'minor changes', 'minor changes']","{'Name': 'src/algorithms/math/binary/images/decimalToBinary.PNG', 'Line Additions': 0, 'Line Deletions': 0, 'Patch': None}",[]
52,373,open,binary-search-tree fake code error.,2,"['src/data-structures/tree/binary-search-tree/README.md', 'src/data-structures/tree/binary-search-tree/README.pt-BR.md']",1,['fix fake code error of traversal'],"{'Name': 'src/data-structures/tree/binary-search-tree/README.pt-BR.md', 'Line Additions': 3, 'Line Deletions': 3, 'Patch': '@@ -222,7 +222,7 @@ end findMax\n inorder(root)\n   Pre: root is the root node of the BST\n   Post: the nodes in the BST have been visited in inorder\n-  if root = ø\n+  if root != ø\n     inorder(root.left)\n     yield root.value\n     inorder(root.right)\n@@ -236,7 +236,7 @@ end inorder\n preorder(root)\n   Pre: root is the root node of the BST\n   Post: the nodes in the BST have been visited in preorder\n-  if root = ø\n+  if root != ø\n     yield root.value\n     preorder(root.left)\n     preorder(root.right)\n@@ -250,7 +250,7 @@ end preorder\n postorder(root)\n   Pre: root is the root node of the BST\n   Post: the nodes in the BST have been visited in postorder\n-  if root = ø\n+  if root != ø\n     postorder(root.left)\n     postorder(root.right)\n     yield root.value'}",[]
53,377,open,,1,['src/data-structures/tree/avl-tree/AvlTree.js'],1,['Fixed balancing of avl tree after insertion or deletion'],"{'Name': 'src/data-structures/tree/avl-tree/AvlTree.js', 'Line Additions': 36, 'Line Deletions': 4, 'Patch': ""@@ -9,9 +9,12 @@ export default class AvlTree extends BinarySearchTree {\n     super.insert(value);\n \n     // Let's move up to the root and check balance factors along the way.\n-    let currentNode = this.root.find(value);\n+    let insertedNode = this.root.find(value);\n+    let currentNode = insertedNode;\n     while (currentNode) {\n-      this.balance(currentNode);\n+      if (this.balanceInsert(currentNode, insertedNode)) {\n+        return;\n+      }\n       currentNode = currentNode.parent;\n     }\n   }\n@@ -25,13 +28,42 @@ export default class AvlTree extends BinarySearchTree {\n     super.remove(value);\n \n     // Balance the tree starting from the root node.\n-    this.balance(this.root);\n+\n+    let currentNode = this.root.find(value);\n+    \n+    while(currentNode) {\n+      this.balanceRemove(currentNode);\n+      currentNode = currentNode.parent;\n+    }\n+  }\n+\n+  /**\n+   * @param {BinarySearchTreeNode} node\n+   * @return {Boolean}\n+   */\n+  balanceInsert(node, insertedNode) {\n+    if (node.balanceFactor > 1) {\n+      if (insertedNode.value < node.value) {\n+        this.rotateLeftLeft(node);\n+      } else {\n+        this.rotateLeftRight(node);\n+      }\n+      return true;\n+    } else if (node.balanceFactor < -1) {\n+      if (insertedNode.value > node.value) {\n+        this.rotateRightRight(node);\n+      } else {\n+        this.rotateRightLeft(node);\n+      }\n+      return true;\n+    }\n+    return false;\n   }\n \n   /**\n    * @param {BinarySearchTreeNode} node\n    */\n-  balance(node) {\n+  balanceRemove(node) {\n     // If balance factor is not OK then try to balance the node.\n     if (node.balanceFactor > 1) {\n       // Left rotation.""}",[]
54,379,open,"The code will now throw error if someone tries to index values less than 1.
Also code still works for n == 1 case.",4,"['src/algorithms/math/fibonacci/__test__/fibonacci.test.js', 'src/algorithms/math/fibonacci/__test__/fibonacciNth.test.js', 'src/algorithms/math/fibonacci/fibonacci.js', 'src/algorithms/math/fibonacci/fibonacciNth.js']",11,"['throw error for wrong index', 'throw error for wrong index..', 'add comment for code', 'correcting error', 'checking lint errors', 'checking lint errors', 'correcting lint errors', 'Adding test for error condition', 'adding test for error case', 'updating test', 'Update test']","{'Name': 'src/algorithms/math/fibonacci/fibonacciNth.js', 'Line Additions': 3, 'Line Deletions': 2, 'Patch': ""@@ -8,8 +8,9 @@ export default function fibonacciNth(n) {\n   let currentValue = 1;\n   let previousValue = 0;\n \n-  if (n === 1) {\n-    return 1;\n+  // Throw error if index is not correct\n+  if (n < 1) {\n+    throw new Error('Cannot have values less than 1');\n   }\n \n   let iterationsCounter = n - 1;""}",[]
55,380,open,"adding Bucket sort, the algorithm works for the 'sort.testSort()' test, but i'm not sure what the 'testSortWithCustomComparator' and the rest of those mean, or how to implement them. So please feel free to update the sort to work with those. ",3,"['src/algorithms/sorting/Bucket-sort/BucketSort.js', 'src/algorithms/sorting/Bucket-sort/README.md', 'src/algorithms/sorting/Bucket-sort/__test__/BucketSort.test.js']",3,"['Bucket Sort\n\nNot perfect but a good start', 'updated read me', 'read me']","{'Name': 'src/algorithms/sorting/Bucket-sort/__test__/BucketSort.test.js', 'Line Additions': 64, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,64 @@\n+import BucketSort from '../BucketSort';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+// Complexity constants.\n+// const SORTED_ARRAY_VISITING_COUNT = 20;\n+// const NOT_SORTED_ARRAY_VISITING_COUNT = 189;\n+// const REVERSE_SORTED_ARRAY_VISITING_COUNT = 209;\n+// const EQUAL_ARRAY_VISITING_COUNT = 20;\n+\n+describe('BucketSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(BucketSort);\n+  });\n+\n+  // it('should sort array with custom comparator', () => {\n+  //   SortTester.testSortWithCustomComparator(BucketSort);\n+  // });\n+\n+  // it('should do stable sorting', () => {\n+  //   SortTester.testSortStability(BucketSort);\n+  // });\n+\n+  // it('should sort negative numbers', () => {\n+  //   SortTester.testNegativeNumbersSort(BucketSort);\n+  // });\n+\n+  // it('should visit EQUAL array element specified number of times', () => {\n+  //   SortTester.testAlgorithmTimeComplexity(\n+  //     BucketSort,\n+  //     equalArr,\n+  //     EQUAL_ARRAY_VISITING_COUNT,\n+  //   );\n+  // });\n+\n+  // it('should visit SORTED array element specified number of times', () => {\n+  //   SortTester.testAlgorithmTimeComplexity(\n+  //     BucketSort,\n+  //     sortedArr,\n+  //     SORTED_ARRAY_VISITING_COUNT,\n+  //   );\n+  // });\n+\n+  // it('should visit NOT SORTED array element specified number of times', () => {\n+  //   SortTester.testAlgorithmTimeComplexity(\n+  //     BucketSort,\n+  //     notSortedArr,\n+  //     NOT_SORTED_ARRAY_VISITING_COUNT,\n+  //   );\n+  // });\n+\n+  // it('should visit REVERSE SORTED array element specified number of times', () => {\n+  //   SortTester.testAlgorithmTimeComplexity(\n+  //     BucketSort,\n+  //     reverseArr,\n+  //     REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+  //   );\n+  // });\n+});""}",[]
56,381,open,I am playing with comments to get final results about this,1,['src/data-structures/stack/__test__/Stack.test.js'],2,"['Update Stack.test.js', 'adding a new comment to the file']","{'Name': 'src/data-structures/stack/__test__/Stack.test.js', 'Line Additions': 4, 'Line Deletions': 0, 'Patch': ""@@ -75,3 +75,7 @@ describe('Stack', () => {\n     expect(stack.toArray()).toEqual([3, 2, 1]);\n   });\n });\n+\n+\n+//adding a comment\n+//another comment with the difference of a new branch""}",[]
57,382,open,"Hello guys! I saw the project and I like so much of maths algorithms. I saw the fibonacci sequence, that is perfect, but I remember of other sequence, the tribonacci sequence, so what I did was implent this and the respectives tests. 

Basically is like fibonacci, but sum the three last elements from sequence. References:

https://brilliant.org/wiki/tribonacci-sequence/
http://mathworld.wolfram.com/TribonacciNumber.html
https://math.stackexchange.com/questions/2280243/tribonacci-sequence-term",5,"['src/algorithms/math/tribonacci/README.md', 'src/algorithms/math/tribonacci/__test__/tribonacci.test.js', 'src/algorithms/math/tribonacci/__test__/tribonacciNth.test.js', 'src/algorithms/math/tribonacci/tribonacci.js', 'src/algorithms/math/tribonacci/tribonacciNth.js']",8,"['Tribonacci sequence', 'Fixing name of file', 'Adding tests to tribonacci', 'Adding readme', 'Fixing the spaces identation', 'Fixing the spaces', 'Fixing the algorithm', 'Shore refacto']","{'Name': 'src/algorithms/math/tribonacci/tribonacciNth.js', 'Line Additions': 17, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,17 @@\n+/**\n+ * Calculate tribonacci number at specific position using Dynamic Programming approach.\n+ *\n+ * @param n\n+ * @return {number}\n+ */\n+export default function tribonacciNth(n) {\n+  const tribSequence = [0, 0, 1];\n+  let currentValue = 1;\n+\n+  for (let i = 3; i <= n; i += 1) {\n+    tribSequence.push(currentValue);\n+    currentValue += tribSequence[i - 1] + tribSequence[i - 2];\n+  }\n+\n+  return tribSequence[n];\n+}'}",[]
58,384,open,Traversing the list to find the last node and add the new data,1,['src/data-structures/linked-list/LinkedList.js'],1,['Update LinkedList.js\n\nTraversing the list to find the last node and add the new data'],"{'Name': 'src/data-structures/linked-list/LinkedList.js', 'Line Additions': 6, 'Line Deletions': 0, 'Patch': '@@ -48,6 +48,12 @@ export default class LinkedList {\n     }\n \n     // Attach new node to the end of linked list.\n+    let current = this.head;\n+    while (current.next !== null) {\n+        current = current.next;\n+    }\n+    current.next = newNode;\n+    \n     this.tail.next = newNode;\n     this.tail = newNode;\n '}",[]
59,387,open,,3,"['package-lock.json', 'src/algorithms/math/fibonacci/__test__/fibonacciMatriz.test.js', 'src/algorithms/math/fibonacci/fibonacciMatriz.js']",1,['Calculate fibonacci using Matriz'],"{'Name': 'src/algorithms/math/fibonacci/fibonacciMatriz.js', 'Line Additions': 46, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,46 @@\n+/**\n+ * Multiply two matrices 2x2\n+ *\n+ * @param {number} matrizA - Matriz calculate.\n+ * @param {number} matrizB - Matriz calculate.\n+ * @return {number}\n+ */\n+function multMatriz(matrizA, matrizB) {\n+  return [[matrizA[0][0] * matrizB[0][0] + matrizA[0][1] * matrizB[1][0],\n+    matrizA[0][0] * matrizB[0][1] + matrizA[0][1] * matrizB[1][1]],\n+  [matrizA[1][0] * matrizB[0][0] + matrizA[1][1] * matrizB[1][0],\n+    matrizA[1][0] * matrizB[0][1] + matrizA[1][1] * matrizB[1][1]]];\n+}\n+\n+/**\n+ * Pow matriz O(lg n)\n+ *\n+ * @param {number} matriz - Matriz calculate.\n+ * @param {number} exp - Number exponent.\n+ * @return {number}\n+ */\n+function powMatriz(matriz, exp) {\n+  if (exp === 0) return [[1, 0], [0, 1]];\n+\n+  if (exp % 2 === 0) {\n+    const temp = powMatriz(matriz, Math.floor(exp / 2));\n+    return multMatriz(temp, temp);\n+  }\n+\n+  let temp = powMatriz(matriz, Math.floor(exp / 2));\n+  temp = multMatriz(temp, temp);\n+  return multMatriz(matriz, temp);\n+}\n+\n+/**\n+ * Calculate fibonacci number at specific position using matriz exponation.\n+ *\n+ * @param {number} position - Position number of fibonacci sequence.\n+ * @return {number}\n+ */\n+export default function fibonacciMatriz(position) {\n+  if (position < 2) return position;\n+  const matriz = [[0, 1], [1, 1]];\n+  const result = powMatriz(matriz, position);\n+  return result[0][1];\n+}'}",[]
60,389,open,"##  Optimize the performance of insert sort

###  The main problem
If currentIndex is equal to 0, you can abort while

###  validation

#### 1: Create the test file
```bash
touch -p src/algorithms/sorting/insertion-sort/__test__/Performance.test.js
```

#### 2: The file writes the following
```javascript
import InsertionSort from ""../InsertionSort"";

function PerformanceTesting() {
  function initArray() {
    let array = [];
    const max = Math.pow(10, 4.5);
    for (let i = max; i > 0; i--) {
      array.push(i);
    }
    return array;
  }

  const sorter = new InsertionSort();
  const array = initArray();

  let start = Date.now();
  sorter.sort(array);

  const ms = Date.now() - start;
  return ms;
}

describe(""PerformanceTesting"", () => {
  it(""PerformanceTesting times"", () => {
    const InsertionSortMs = PerformanceTesting(InsertionSort);
    console.log(`InsertionSort times: ${InsertionSortMs}ms`);
  });
});
```
#### 3: The results 
#### Has not changed:   6007ms
#### After the changes: 1729ms",1,['src/algorithms/sorting/insertion-sort/InsertionSort.js'],3,"['Optimize insertion sort', 'Fix code style', 'Fix code style']","{'Name': 'src/algorithms/sorting/insertion-sort/InsertionSort.js', 'Line Additions': 7, 'Line Deletions': 5, 'Patch': '@@ -8,26 +8,28 @@ export default class InsertionSort extends Sort {\n     for (let i = 0; i < array.length; i += 1) {\n       let currentIndex = i;\n \n+      const temp = array[currentIndex];\n+\n       // Call visiting callback.\n       this.callbacks.visitingCallback(array[i]);\n \n       // Go and check if previous elements and greater then current one.\n       // If this is the case then swap that elements.\n       while (\n-        array[currentIndex - 1] !== undefined\n-        && this.comparator.lessThan(array[currentIndex], array[currentIndex - 1])\n+        currentIndex > 0\n+        && this.comparator.lessThan(temp, array[currentIndex - 1])\n       ) {\n         // Call visiting callback.\n         this.callbacks.visitingCallback(array[currentIndex - 1]);\n \n         // Swap the elements.\n-        const tmp = array[currentIndex - 1];\n-        array[currentIndex - 1] = array[currentIndex];\n-        array[currentIndex] = tmp;\n+        array[currentIndex] = array[currentIndex - 1];\n \n         // Shift current index left.\n         currentIndex -= 1;\n       }\n+\n+      array[currentIndex] = temp;\n     }\n \n     return array;'}",[]
61,390,open,"Gnome sort algorithm :)

Font: https://en.wikipedia.org/wiki/Gnome_sort",3,"['src/algorithms/sorting/gnome-sort/GnomeSort.js', 'src/algorithms/sorting/gnome-sort/README.md', 'src/algorithms/sorting/gnome-sort/__test__/GnomeSort.test.js']",5,"['Add algorithm of GnomeSort', 'Tests for GnomeSort algorithm', 'README.md introducted', 'Change syntax for follow the pattern', 'Fix gnome algorithm']","{'Name': 'src/algorithms/sorting/gnome-sort/__test__/GnomeSort.test.js', 'Line Additions': 14, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,14 @@\n+import GnomeSort from '../GnomeSort';\n+import {\n+  SortTester,\n+} from '../../SortTester';\n+\n+describe('GnomeSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(GnomeSort);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(GnomeSort);\n+  });\n+});""}",[]
62,400,open,Removed redundant condition,1,['src/algorithms/math/fibonacci/fibonacci.js'],1,['Refactoring fibonacci algorithm'],"{'Name': 'src/algorithms/math/fibonacci/fibonacci.js', 'Line Additions': 0, 'Line Deletions': 4, 'Patch': '@@ -10,10 +10,6 @@ export default function fibonacci(n) {\n   let currentValue = 1;\n   let previousValue = 0;\n \n-  if (n === 1) {\n-    return fibSequence;\n-  }\n-\n   let iterationsCounter = n - 1;\n \n   while (iterationsCounter) {'}",[]
63,401,open,"added a new category of algorithms, inside the algorithms directory.
It contains problems, concerning the frequency counter algorithms.",4,"['src/algorithms/Fequency Counter based/Anagrams.js', 'src/algorithms/Fequency Counter based/areEqualNoOfSquares.js', 'src/algorithms/Fequency Counter based/areThereDuplicates_FQ.js', 'src/algorithms/Fequency Counter based/sameFrequency.js']",1,['added frequency counter algorithm based problems.'],"{'Name': 'src/algorithms/Fequency Counter based/sameFrequency.js', 'Line Additions': 37, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,37 @@\n+//Numeric anagrams detector\n+\n+function sameFrequency(strA, strB) {\n+\n+//convert the array, into a string\n+    var str1 = strA.toString()\n+      , str2 = strB.toString();\n+\n+    if (str1.length !== str2.length) {\n+        return false;\n+    }\n+\n+    var freqCounter1 = {}\n+      , freqCounter2 = {};\n+\n+\n+    for (let val of str1) {\n+        freqCounter1[val] = (freqCounter1[val] || 0) + 1;\n+    }\n+\n+    for (let val of str2) {\n+        freqCounter2[val] = (freqCounter2[val] || 0) + 1;\n+    }\n+\n+    for (let key in freqCounter1) {\n+        if (!(key in freqCounter2)) {\n+            return false;\n+        }\n+\n+        if (freqCounter2[key] !== freqCounter1[key]) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+sameFrequency(552181, 152581);'}",[]
64,402,open,issue #394 has been solved,1,['countingsort.js'],1,['added counting sort repo'],"{'Name': 'countingsort.js', 'Line Additions': 22, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,22 @@\n+let countingSort = (arr, min, max) => {\r\n+    let i = min,\r\n+        j = 0,\r\n+        len = arr.length,\r\n+        count = [];\r\n+    for (i; i <= max; i++) {\r\n+        count[i] = 0;\r\n+    }\r\n+    for (i = 0; i < len; i++) {\r\n+        count[arr[i]] += 1;\r\n+    }\r\n+    for (i = min; i <= max; i++) {\r\n+        while (count[i] > 0) {\r\n+            arr[j] = i;\r\n+            j++;\r\n+            count[i]--;\r\n+        }\r\n+    }\r\n+    return arr;\r\n+};\r\n+\r\n+\r'}",[]
65,403,open,,1,['fibb.js'],1,['create fibonacci code'],"{'Name': 'fibb.js', 'Line Additions': 16, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,16 @@\n+var fibonacci_series = function (n) \n+{\n+  if (n===1) \n+  {\n+    return [0, 1];\n+  } \n+  else \n+  {\n+    var s = fibonacci_series(n - 1);\n+    s.push(s[s.length - 1] + s[s.length - 2]);\n+    return s;\n+  }\n+};\n+\n+ console.log(fibonacci_series(8));\n+ '}",[]
66,407,open,,2,"['src/data-structures/graph/Graph.js', 'src/data-structures/graph/__test__/Graph.test.js']",1,['Implemented method to generate adjacency list for graph'],"{'Name': 'src/data-structures/graph/__test__/Graph.test.js', 'Line Additions': 55, 'Line Deletions': 0, 'Patch': ""@@ -385,4 +385,59 @@ describe('Graph', () => {\n       [Infinity, Infinity, Infinity, Infinity],\n     ]);\n   });\n+\n+  it('should generate adjacency list for undirected graph', () => {\n+    const vertexA = new GraphVertex('A');\n+    const vertexB = new GraphVertex('B');\n+    const vertexC = new GraphVertex('C');\n+    const vertexD = new GraphVertex('D');\n+\n+    const edgeAB = new GraphEdge(vertexA, vertexB, 2);\n+    const edgeBC = new GraphEdge(vertexB, vertexC, 1);\n+    const edgeCD = new GraphEdge(vertexC, vertexD, 5);\n+    const edgeBD = new GraphEdge(vertexB, vertexD, 7);\n+\n+    const graph = new Graph();\n+    graph\n+      .addEdge(edgeAB)\n+      .addEdge(edgeBC)\n+      .addEdge(edgeCD)\n+      .addEdge(edgeBD);\n+\n+    const adjacencyList = graph.getAdjacencyList();\n+\n+    expect(adjacencyList).toEqual({\n+      A: [{ value: 'B', weight: 2 }],\n+      B: [{ value: 'A', weight: 2 }, { value: 'C', weight: 1 }, { value: 'D', weight: 7 }],\n+      C: [{ value: 'B', weight: 1 }, { value: 'D', weight: 5 }],\n+      D: [{ value: 'C', weight: 5 }, { value: 'B', weight: 7 }],\n+    });\n+  });\n+\n+  it('should generate adjacency list for directed graph', () => {\n+    const vertexA = new GraphVertex('A');\n+    const vertexB = new GraphVertex('B');\n+    const vertexC = new GraphVertex('C');\n+    const vertexD = new GraphVertex('D');\n+\n+    const edgeAB = new GraphEdge(vertexA, vertexB, 2);\n+    const edgeBC = new GraphEdge(vertexB, vertexC, 1);\n+    const edgeCD = new GraphEdge(vertexC, vertexD, 5);\n+    const edgeBD = new GraphEdge(vertexB, vertexD, 7);\n+\n+    const graph = new Graph(true);\n+    graph\n+      .addEdge(edgeAB)\n+      .addEdge(edgeBC)\n+      .addEdge(edgeCD)\n+      .addEdge(edgeBD);\n+\n+    const adjacencyList = graph.getAdjacencyList();\n+\n+    expect(adjacencyList).toEqual({\n+      A: [{ value: 'B', weight: 2 }],\n+      B: [{ value: 'C', weight: 1 }, { value: 'D', weight: 7 }],\n+      C: [{ value: 'D', weight: 5 }],\n+    });\n+  });\n });""}",[]
67,410,open,,1,['src/algorithms/uncategorized/palindrome.js'],1,['palindrome program'],"{'Name': 'src/algorithms/uncategorized/palindrome.js', 'Line Additions': 5, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,5 @@\n+function palindrome(text) {\n+var reversedText  = text.toLowerCase()\n+                    .split('').reverse().join('');\n+return text === reversedText;\n+}""}",[]
68,411,open,,1,['BFS.js'],1,['adding BFS'],"{'Name': 'BFS.js', 'Line Additions': 174, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,174 @@\n+import Graph from '../../../../data-structures/Graph/Graph';\n+import GraphVertex from '../../../../data-structures/Graph/GraphVertex';\n+import GraphEdge from '../../../../data-structures/Graph/GraphEdge';\n+import breadthFirstSearch from '../breadthFirstSearch';\n+\n+describe('breadthFirstSearch', () => {\n+  it('should perform BFS operation on Graph', () => {\n+    const Graph = new Graph(true);\n+\n+    const vertexA = new GraphVertex('A');\n+    const vertexB = new GraphVertex('B');\n+    const vertexC = new GraphVertex('C');\n+    const vertexD = new GraphVertex('D');\n+    const vertexE = new GraphVertex('E');\n+    const vertexF = new GraphVertex('F');\n+    const vertexG = new GraphVertex('G');\n+    const vertexH = new GraphVertex('H');\n+\n+    const edgeAB = new GraphEdge(vertexA, vertexB);\n+    const edgeBC = new GraphEdge(vertexB, vertexC);\n+    const edgeCG = new GraphEdge(vertexC, vertexG);\n+    const edgeAD = new GraphEdge(vertexA, vertexD);\n+    const edgeAE = new GraphEdge(vertexA, vertexE);\n+    const edgeEF = new GraphEdge(vertexE, vertexF);\n+    const edgeFD = new GraphEdge(vertexF, vertexD);\n+    const edgeDH = new GraphEdge(vertexD, vertexH);\n+    const edgeGH = new GraphEdge(vertexG, vertexH);\n+\n+    Graph\n+      .addEdge(edgeAB)\n+      .addEdge(edgeBC)\n+      .addEdge(edgeCG)\n+      .addEdge(edgeAD)\n+      .addEdge(edgeAE)\n+      .addEdge(edgeEF)\n+      .addEdge(edgeFD)\n+      .addEdge(edgeDH)\n+      .addEdge(edgeGH);\n+\n+    expect(Graph.toString()).toBe('A,B,C,G,D,E,F,H');\n+\n+    const enterVertexCallback = jest.fn();\n+    const leaveVertexCallback = jest.fn();\n+\n+    // Traverse Graphs without callbacks first.\n+    breadthFirstSearch(Graph, vertexA);\n+\n+    // Traverse Graph with enterVertex and leaveVertex callbacks.\n+    breadthFirstSearch(Graph, vertexA, {\n+      enterVertex: enterVertexCallback,\n+      leaveVertex: leaveVertexCallback,\n+    });\n+\n+    expect(enterVertexCallback).toHaveBeenCalledTimes(8);\n+    expect(leaveVertexCallback).toHaveBeenCalledTimes(8);\n+\n+    const enterVertexParamsMap = [\n+      { currentVertex: vertexA, previousVertex: null },\n+      { currentVertex: vertexB, previousVertex: vertexA },\n+      { currentVertex: vertexD, previousVertex: vertexB },\n+      { currentVertex: vertexE, previousVertex: vertexD },\n+      { currentVertex: vertexC, previousVertex: vertexE },\n+      { currentVertex: vertexH, previousVertex: vertexC },\n+      { currentVertex: vertexF, previousVertex: vertexH },\n+      { currentVertex: vertexG, previousVertex: vertexF },\n+    ];\n+\n+    for (let callIndex = 0; callIndex < Graph.getAllVertices().length; callIndex += 1) {\n+      const params = enterVertexCallback.mock.calls[callIndex][0];\n+      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);\n+      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);\n+    }\n+\n+    const leaveVertexParamsMap = [\n+      { currentVertex: vertexA, previousVertex: null },\n+      { currentVertex: vertexB, previousVertex: vertexA },\n+      { currentVertex: vertexD, previousVertex: vertexB },\n+      { currentVertex: vertexE, previousVertex: vertexD },\n+      { currentVertex: vertexC, previousVertex: vertexE },\n+      { currentVertex: vertexH, previousVertex: vertexC },\n+      { currentVertex: vertexF, previousVertex: vertexH },\n+      { currentVertex: vertexG, previousVertex: vertexF },\n+    ];\n+\n+    for (let callIndex = 0; callIndex < Graph.getAllVertices().length; callIndex += 1) {\n+      const params = leaveVertexCallback.mock.calls[callIndex][0];\n+      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);\n+      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);\n+    }\n+  });\n+\n+  it('should allow to create custom vertex visiting logic', () => {\n+    const Graph = new Graph(true);\n+\n+    const vertexA = new GraphVertex('A');\n+    const vertexB = new GraphVertex('B');\n+    const vertexC = new GraphVertex('C');\n+    const vertexD = new GraphVertex('D');\n+    const vertexE = new GraphVertex('E');\n+    const vertexF = new GraphVertex('F');\n+    const vertexG = new GraphVertex('G');\n+    const vertexH = new GraphVertex('H');\n+\n+    const edgeAB = new GraphEdge(vertexA, vertexB);\n+    const edgeBC = new GraphEdge(vertexB, vertexC);\n+    const edgeCG = new GraphEdge(vertexC, vertexG);\n+    const edgeAD = new GraphEdge(vertexA, vertexD);\n+    const edgeAE = new GraphEdge(vertexA, vertexE);\n+    const edgeEF = new GraphEdge(vertexE, vertexF);\n+    const edgeFD = new GraphEdge(vertexF, vertexD);\n+    const edgeDH = new GraphEdge(vertexD, vertexH);\n+    const edgeGH = new GraphEdge(vertexG, vertexH);\n+\n+    Graph\n+      .addEdge(edgeAB)\n+      .addEdge(edgeBC)\n+      .addEdge(edgeCG)\n+      .addEdge(edgeAD)\n+      .addEdge(edgeAE)\n+      .addEdge(edgeEF)\n+      .addEdge(edgeFD)\n+      .addEdge(edgeDH)\n+      .addEdge(edgeGH);\n+\n+    expect(Graph.toString()).toBe('A,B,C,G,D,E,F,H');\n+\n+    const enterVertexCallback = jest.fn();\n+    const leaveVertexCallback = jest.fn();\n+\n+    // Traverse Graph with enterVertex and leaveVertex callbacks.\n+    breadthFirstSearch(Graph, vertexA, {\n+      enterVertex: enterVertexCallback,\n+      leaveVertex: leaveVertexCallback,\n+      allowTraversal: ({ currentVertex, nextVertex }) => {\n+        return !(currentVertex === vertexA && nextVertex === vertexB);\n+      },\n+    });\n+\n+    expect(enterVertexCallback).toHaveBeenCalledTimes(7);\n+    expect(leaveVertexCallback).toHaveBeenCalledTimes(7);\n+\n+    const enterVertexParamsMap = [\n+      { currentVertex: vertexA, previousVertex: null },\n+      { currentVertex: vertexD, previousVertex: vertexA },\n+      { currentVertex: vertexE, previousVertex: vertexD },\n+      { currentVertex: vertexH, previousVertex: vertexE },\n+      { currentVertex: vertexF, previousVertex: vertexH },\n+      { currentVertex: vertexD, previousVertex: vertexF },\n+      { currentVertex: vertexH, previousVertex: vertexD },\n+    ];\n+\n+    for (let callIndex = 0; callIndex < 7; callIndex += 1) {\n+      const params = enterVertexCallback.mock.calls[callIndex][0];\n+      expect(params.currentVertex).toEqual(enterVertexParamsMap[callIndex].currentVertex);\n+      expect(params.previousVertex).toEqual(enterVertexParamsMap[callIndex].previousVertex);\n+    }\n+\n+    const leaveVertexParamsMap = [\n+      { currentVertex: vertexA, previousVertex: null },\n+      { currentVertex: vertexD, previousVertex: vertexA },\n+      { currentVertex: vertexE, previousVertex: vertexD },\n+      { currentVertex: vertexH, previousVertex: vertexE },\n+      { currentVertex: vertexF, previousVertex: vertexH },\n+      { currentVertex: vertexD, previousVertex: vertexF },\n+      { currentVertex: vertexH, previousVertex: vertexD },\n+    ];\n+\n+    for (let callIndex = 0; callIndex < 7; callIndex += 1) {\n+      const params = leaveVertexCallback.mock.calls[callIndex][0];\n+      expect(params.currentVertex).toEqual(leaveVertexParamsMap[callIndex].currentVertex);\n+      expect(params.previousVertex).toEqual(leaveVertexParamsMap[callIndex].previousVertex);\n+    }\n+  });\n+});\n\\ No newline at end of file""}",[]
69,412,open,,1,['src/algorithms/sorting/heap-sort/README.pt-BR.md'],1,['Add pt-BR translation for Heap Sort'],"{'Name': 'src/algorithms/sorting/heap-sort/README.pt-BR.md', 'Line Additions': 24, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,24 @@\n+# Heap Sort\n+\n+Heapsort é um algoritmo de classificação baseado em comparação.\n+O Heapsort pode ser considerado como uma classificação de seleção\n+aprimorada: assim como o algoritmo, ele divide sua entrada em uma \n+região classificada e uma região não classificada, e reduz \n+iterativamente a região não classificada, extraindo o elemento maior\n+e movendo-o para a região classificada. A melhoria consiste no uso de\n+uma estrutura de dados de heap em vez de uma pesquisa em tempo linear\n+para encontrar o máximo.\n+\n+![Visualização do Algoritmo](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)\n+\n+![Visualização do Algoritmo](https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif)\n+\n+## Complexidade\n+\n+| Nome                  | Melhor          | Média               | Pior                | Memória   | Estável   | Comentários |\n+| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :--------   |\n+| **Heap sort**         | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | 1         | Não       |             |\n+\n+## Referências\n+\n+[Wikipedia](https://en.wikipedia.org/wiki/Heapsort)'}",[]
70,413,open,,1,['src/algorithms/sorting/selection-sort/README.pt-BR.md'],1,['Add pt-BR translation for Selection Sort'],"{'Name': 'src/algorithms/sorting/selection-sort/README.pt-BR.md', 'Line Additions': 25, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,25 @@\n+# Ordenação por Seleção\n+\n+A classificação por seleção é um algoritmo de classificação, \n+especificamente uma classificação de comparação no local. \n+Possui complexidade de tempo O (n2), tornando-o ineficiente \n+em listas grandes e geralmente apresenta desempenho pior que \n+o tipo de inserção semelhante. \n+A classificação de seleção é notada por sua simplicidade e \n+possui vantagens de desempenho em relação a algoritmos mais \n+complicados em determinadas situações, particularmente onde \n+a memória auxiliar é limitada.\n+\n+![Visualização do Algoritmo](https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)\n+\n+![Visualização do Algoritmo](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)\n+\n+## Complexidade\n+\n+| Nome                  | Melhor          | Média               | Pior                | Memória   | Estável   | Comentários |\n+| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :--------   |\n+| **Selection sort**    | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Não       |             |\n+\n+## Referências\n+\n+[Wikipedia](https://en.wikipedia.org/wiki/Selection_sort)'}",[]
71,414,open,Feature for issue #406.,3,"['src/algorithms/cryptography/vigenere-cipher/README.md', 'src/algorithms/cryptography/vigenere-cipher/VigenereCipher.js', 'src/algorithms/cryptography/vigenere-cipher/__test__/VigenereCipher.test.js']",1,['Adding Vigenere cipher (issue #406)'],"{'Name': 'src/algorithms/cryptography/vigenere-cipher/__test__/VigenereCipher.test.js', 'Line Additions': 45, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,45 @@\n+import vigenereCipher from '../VigenereCipher';\n+\n+describe('Vigenere cipher tests', () => {\n+  it('should generate LXFOPVEFRNHR for the word ATTACKATDAWN when using the key LEMON', () => {\n+    const word = 'ATTACKATDAWN';\n+    const keyword = 'LEMON';\n+    const expectedResult = 'LXFOPVEFRNHR';\n+\n+    const result = vigenereCipher.encrypt(word, keyword);\n+\n+    expect(result).toBe(expectedResult);\n+  });\n+\n+  it('should decrypt to ATTACKATDAWN when using hash LXFOPVEFRNHR with key LEMON', () => {\n+    const hash = 'LXFOPVEFRNHR';\n+    const keyword = 'LEMON';\n+    const expectedResult = 'ATTACKATDAWN';\n+\n+    const result = vigenereCipher.decrypt(hash, keyword);\n+\n+    expect(result).toBe(expectedResult);\n+  });\n+\n+  it('should adapt key when it is longer than the word when encrypting', () => {\n+    const word = 'ATTACKATDAWN';\n+    const keywordWithinBounds = 'LEMON';\n+    const keywordOutOfBounds = 'LEMONLEMONLEMON';\n+\n+    const resultUsingKeywordWithinBounds = vigenereCipher.encrypt(word, keywordWithinBounds);\n+    const resultUsingKeywordOutOfBounds = vigenereCipher.encrypt(word, keywordOutOfBounds);\n+\n+    expect(resultUsingKeywordWithinBounds).toBe(resultUsingKeywordOutOfBounds);\n+  });\n+\n+  it('should adapt key when it is longer than the word when decrypting', () => {\n+    const hash = 'LXFOPVEFRNHR';\n+    const keywordWithinBounds = 'LEMON';\n+    const keywordOutOfBounds = 'LEMONLEMONLEMON';\n+\n+    const resultUsingKeywordWithinBounds = vigenereCipher.decrypt(hash, keywordWithinBounds);\n+    const resultUsingKeywordOutOfBounds = vigenereCipher.decrypt(hash, keywordOutOfBounds);\n+\n+    expect(resultUsingKeywordWithinBounds).toBe(resultUsingKeywordOutOfBounds);\n+  });\n+});""}",[]
72,415,open,,3,"['src/algorithms/search/sentinal-linear-search/README.md', 'src/algorithms/search/sentinal-linear-search/__test__/sentinalLinearSearch.test.js', 'src/algorithms/search/sentinal-linear-search/sentinalLinearSearch.js']",3,"['Adding sentinal linear search', 'Adding indentation fix', 'Update sentinalLinearSearch.js\n\nTest case fix']","{'Name': 'src/algorithms/search/sentinal-linear-search/sentinalLinearSearch.js', 'Line Additions': 32, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,32 @@\n+import Comparator from '../../../utils/comparator/Comparator';\n+\n+/**\n+ * Sentinal Linear search implementation.\n+ *\n+ * @param {*[]} array\n+ * @param {*} seekElement\n+ * @param {function(a, b)} [comparatorCallback]\n+ * @return {number[]}\n+ */\n+export default function sentinalLinearSearch(array, seekElement, comparatorCallback) {\n+  const comparator = new Comparator(comparatorCallback);\n+  const foundIndices = [];\n+  const lastEle = array[array.length - 1]; // Picking the last element in the array\n+  const i = 0;\n+\n+  while (comparator.notEqual(i, array.length - 1)) {\n+    while(comparator.notEqual(array[i], seekElement)) {\n+      i = i + 1;\n+    }\n+    if(comparator.notEqual(i, array.length - 1)) {\n+      foundIndices.push(i);\n+      i = i + 1;\n+    }\n+  }\n+  array[array.length - 1] = lastEle; // Replacing the last element\n+\n+  if (comparator.equal(array[array.length - 1], seekElement)) {\n+    foundIndices.push(i);\n+  }\n+  return foundIndices;\n+}""}",[]
73,416,open,"Hi! there, :slightly_smiling_face:

this PR simplifies code contributions by fully automating the setup with Gitpod  (A free online VS Code like IDE) for contributing.

With a single click, it'll launch a workspace and automatically:

- clone the javascript-algorithms repo.
- install the dependencies.


You can give it a try on my fork of the repo: https://gitpod.io/#https://github.com/nisarhassan12/javascript-algorithms

![image](https://user-images.githubusercontent.com/46004116/67198217-fe563b00-f417-11e9-9e04-d180509185b6.png)

It seems to work well! Please let me know if there is anything that can be improved. I would love to help :)",10,"['.gitpod.yml', 'README.es-ES.md', 'README.fr-FR.md', 'README.ja-JP.md', 'README.ko-KR.md', 'README.md', 'README.pl-PL.md', 'README.pt-BR.md', 'README.zh-CN.md', 'README.zh-TW.md']",1,['Configures Gitpod.'],"{'Name': 'README.zh-TW.md', 'Line Additions': 4, 'Line Deletions': 0, 'Patch': '@@ -139,6 +139,10 @@ _Read this in other languages:_\n \n ## 如何使用本知識庫\n \n+您可以按照以下步驟在本地設置此存儲庫，也可以使用[gitpod.io](https://gitpod.io）這樣的免費在線VS-IDE等VS-Code，只需單擊一下，它將啟動一個即可編寫代碼的工作區 預先安裝了所有依賴項，這樣您就可以開始研究該項目，而不會在開發設置上浪費任何寶貴的時間。\n+\n+[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/trekhleb/javascript-algorithms)\n+\n **安裝所有必須套件**\n \n ```'}",[]
74,418,open,"## Fix#417
- Add additional korean document that unadded part

## change
- Update missing part of README.ko-KR.md 

## How Verified
### Notes
- N/A

### References
- https://www.diffchecker.com/wuvG4rka",1,['README.ko-KR.md'],1,['Add: additional korean document that unadded part'],"{'Name': 'README.ko-KR.md', 'Line Additions': 22, 'Line Deletions': 6, 'Patch': ""@@ -32,7 +32,7 @@ _Read this in other languages:_\n * `B` [큐](src/data-structures/queue)\n * `B` [스택](src/data-structures/stack)\n * `B` [해시 테이블](src/data-structures/hash-table)\n-* `B` [힙](src/data-structures/heap)\n+* `B` [힙](src/data-structures/heap) - 최대와 최소 힙\n * `B` [우선순위 큐](src/data-structures/priority-queue)\n * `A` [트라이](src/data-structures/trie)\n * `A` [트리](src/data-structures/tree)\n@@ -57,15 +57,20 @@ _Read this in other languages:_\n * **Math**\n   * `B` [Bit Manipulation](src/algorithms/math/bits) - set/get/update/clear bits, 2의 곱 / 나누기, 음수로 만들기 etc.\n   * `B` [팩토리얼](src/algorithms/math/factorial) \n-  * `B` [피보나치 수](src/algorithms/math/fibonacci)\n+  * `B` [피보나치 수](src/algorithms/math/fibonacci) - 고전적인 closed-from 버전\n   * `B` [소수 판별](src/algorithms/math/primality-test) (trial division 방식)\n   * `B` [유클리드 호제법](src/algorithms/math/euclidean-algorithm) - 최대공약수 (GCD)\n-  * `B` [최소 공배수](src/algorithms/math/least-common-multiple) - LCM\n+  * `B` [최소 공배수](src/algorithms/math/least-common-multiple) - (LCM)\n   * `B` [에라토스테네스의 체](src/algorithms/math/sieve-of-eratosthenes) - 특정수 이하의 모든 소수 찾기\n   * `B` [2의 거듭제곱 판별법](src/algorithms/math/is-power-of-two) - 어떤 수가 2의 거듭제곱인지 판별 (naive 와 bitwise 알고리즘)\n   * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle)\n-  * `A` [자연수 분할](src/algorithms/math/integer-partition)\n+  * `A` [자연수 분할](src/algorithms/math/integer-partition) - 복소수와 기본연산\n+  * `B` [Radian & Degree](src/algorithms/math/radian) - 라디안에서 60분법으로 그리고 60분법에서 라디안으로\n+  * `B` [빠른 제곱](src/algorithms/math/fast-powering)\t\t\n+  * `A` [자연수의 분할](src/algorithms/math/integer-partition)\t\t\n+  * `A` [제곱근](src/algorithms/math/square-root) - Newton's method 사용\n   * `A` [리우 후이 π 알고리즘](src/algorithms/math/liu-hui) - N-각형을 기반으로 π 근사치 구하기\n+  * `A` [이산 푸리에 변환](src/algorithms/math/fourier-transform) - 시간의 함수(신호)를 그것을 구성하는 주파수로 분해한다.\n * **Sets**\n   * `B` [카티지언 프로덕트](src/algorithms/sets/cartesian-product) - 곱집합\n   * `B` [Fisher–Yates 셔플](src/algorithms/sets/fisher-yates) - 유한 시퀀스의 무작위 순열\n@@ -101,6 +106,9 @@ _Read this in other languages:_\n   * `B` [셸 정렬](src/algorithms/sorting/shell-sort)\n   * `B` [계수 정렬](src/algorithms/sorting/counting-sort)\n   * `B` [기수 정렬](src/algorithms/sorting/radix-sort)\n+* **Linked Lists**\t\t\n+  * `B` [Straight 순회](src/algorithms/linked-list/traversal)\t\t\n+  * `B` [Reverse 순회](src/algorithms/linked-list/reverse-traversal)\n * **Trees**\n   * `B` [깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)\n   * `B` [너비 우선 탐색](src/algorithms/tree/breadth-first-search) (BFS)\n@@ -120,12 +128,15 @@ _Read this in other languages:_\n   * `A` [해밀턴 경로](src/algorithms/graph/hamiltonian-cycle) - 모든 꼭짓점을 한번만 방문\n   * `A` [강결합 컴포넌트](src/algorithms/graph/strongly-connected-components) - Kosaraju의 알고리즘\n   * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기\n+* **Cryptography**\t\t\n+  * `B` [Polynomial hash](src/algorithms/cryptography/polynomial-hash) - 다항식을 기반으로 한 rolling hash 함수\n * **Uncategorized**\n   * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower)\n   * `B` [정방 행렬 회전](src/algorithms/uncategorized/square-matrix-rotation) - 제자리(in-place) 알고리즘\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game) - 백트래킹, 동적계획법 (top-down + bottom-up), 탐욕 알고리즘 예제 \n   * `B` [Unique 경로](src/algorithms/uncategorized/unique-paths) - 백트래킹, 동적계획법, 파스칼 삼각형에 기반한 예제\n   * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem (동적계획법, 브루트포스 버전)\n+  * `B` [재귀 계단 문제](src/algorithms/uncategorized/recursive-staircase) - 꼭대기 층에 도달하는 방법을 센다 (4개의 해답)\n   * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)\n   * `A` [기사의 여행 문제](src/algorithms/uncategorized/knight-tour)\n \n@@ -136,8 +147,10 @@ _Read this in other languages:_\n * **브루트 포스(Brute Force)** - 가능한 모든 경우를 탐색한 뒤 최적을 찾아내는 방식입니다.\n   * `B` [선형 탐색](src/algorithms/search/linear-search)\n   * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem\n+  * `B` [재귀 계단 문제](src/algorithms/uncategorized/recursive-staircase) - 꼭대기 층에 도달하는 방법을 센다\t\n   * `A` [최대 구간합](src/algorithms/sets/maximum-subarray)\n   * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기\n+  * `A` [이산 푸리에 변환](src/algorithms/math/fourier-transform) - 시간의 함수(신호)를 그것을 구성하는 주파수로 분해한다.\n * **탐욕 알고리즘(Greedy)** - 이후를 고려하지 않고 현재 시점에서 가장 최적인 선택을 하는 방식입니다.\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n   * `A` [쪼갤수 있는 배낭 문제](src/algorithms/sets/knapsack-problem)\n@@ -154,13 +167,15 @@ _Read this in other languages:_\n   * `B` [트리 깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)\n   * `B` [그래프 깊이 우선 탐색](src/algorithms/graph/depth-first-search) (DFS)\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n+  * `B` [빠른 제곱](src/algorithms/math/fast-powering)\t\n   * `A` [순열](src/algorithms/sets/permutations) (반복 유,무)\n   * `A` [조합](src/algorithms/sets/combinations) (반복 유,무)\n * **동적 계획법(Dynamic Programming)** - 이전에 찾은 결과를 이용하여 최종적으로 해결하는 방식입니다.\n   * `B` [피보나치 수](src/algorithms/math/fibonacci)\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n   * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n   * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem\n+  * `B` [재귀 계단 문제](src/algorithms/uncategorized/recursive-staircase) - 꼭대기 층에 도달하는 방법을 센다\t\n   * `A` [편집 거리](src/algorithms/string/levenshtein-distance) - 두 시퀀스 간의 최소 편집 거리\n   * `A` [최장 공통 부분 수열](src/algorithms/sets/longest-common-subsequence) (LCS)\n   * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring)\n@@ -175,6 +190,7 @@ _Read this in other languages:_\n * **백트래킹(Backtracking)** - 모든 가능한 경우를 고려한다는 점에서 브루트 포스와 유사합니다. 하지만 다음 단계로 넘어갈때 마다 모든 조건을 만족했는지 확인하고 진행합니다. 만약 조건을 만족하지 못했다면 뒤로 돌아갑니다 (백트래킹). 그리고 다른 경로를 선택합니다. 보통 상태를  유지한 DFS 탐색을 많이 사용합니다.\n   * `B` [점프 게임](src/algorithms/uncategorized/jump-game)\n   * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n+  * `B` [멱집합](src/algorithms/sets/power-set) - 집합의 모든 부분집합\t\n   * `A` [해밀턴 경로](src/algorithms/graph/hamiltonian-cycle) - 모든 점을 한번씩 방문\n   * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)\n   * `A` [기사의 여행](src/algorithms/uncategorized/knight-tour)\n@@ -222,9 +238,9 @@ npm test -- 'playground'\n \n [▶ Data Structures and Algorithms on YouTube](https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n \n-### Big O 표기\n+### Big O 표기법\n \n-Big O 표기로 표시한 알고리즘의 증가 양상입니다.\n+*Big O 표기법*은 입력 크기가 커질수록 실행 시간이나 공간 요구사항이 증가하는 방식에 따라 알고리즘을 분류하는 데 사용됩니다. 아래의 차트에서 Big O 표기법으로 명시된 알고리즘의 가장 일반적인 증가지표를 발견할 수 있을 것입니다.\n \n ![Big O graphs](./assets/big-o-graph.png)\n ""}",[]
75,419,open,,1,['src/data-structures/stack/Stack.js'],1,['Update Stack.js'],"{'Name': 'src/data-structures/stack/Stack.js', 'Line Additions': 8, 'Line Deletions': 0, 'Patch': '@@ -56,6 +56,14 @@ export default class Stack {\n       .toArray()\n       .map(linkedListNode => linkedListNode.value);\n   }\n+  \n+  /**\n+   * @return {*}\n+   */\n+  length() {\n+    return this.linkedList\n+      .toArray().length\n+  }\n \n   /**\n    * @param {function} [callback]'}",[]
76,420,open,This PR updates the linearSearch algo with a more modern functional approach. ,1,['src/algorithms/search/linear-search/linearSearch.js'],1,['Update linearSearch with a more functional approach using reduce'],"{'Name': 'src/algorithms/search/linear-search/linearSearch.js', 'Line Additions': 5, 'Line Deletions': 7, 'Patch': ""@@ -10,13 +10,11 @@ import Comparator from '../../../utils/comparator/Comparator';\n  */\n export default function linearSearch(array, seekElement, comparatorCallback) {\n   const comparator = new Comparator(comparatorCallback);\n-  const foundIndices = [];\n \n-  array.forEach((element, index) => {\n-    if (comparator.equal(element, seekElement)) {\n-      foundIndices.push(index);\n+  return array.reduce((accumulator, currentValue, index) => {\n+    if (comparator.equal(currentValue, seekElement)) {\n+      accumulator.push(index);\n     }\n-  });\n-\n-  return foundIndices;\n+    return accumulator;\n+  }, []);\n }""}",[]
77,421,open,To provide a better and more detailed explanation for Big notation added big 0 notation explanation file that is detailed and linked it to the main Readme.md .,2,"['README.md', 'big-o-notation.Eng.md']",3,"['Added a better explain link for big 0 notation', 'Added english version explaination for Big 0 notation', ""Merge branch 'master' into better-explaination-Big0""]","{'Name': 'big-o-notation.Eng.md', 'Line Additions': 242, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,242 @@\n+# Big-0 Notation Primer\n+\n+> *O(1) is holy.* `~Hamid Tizhoosh`\n+\n+The Big-O notation measures the worst-case complexity of an algorithm. In Big-O\n+notation, n represents the number of inputs. The question asked with Big-O is the\n+following: “What will happen as n approaches infinity?”\n+\n+The figure below shows some common Big-O notations:\n+\n+![Big-0 graph](./assets/big-o-graph.png)\n+\n+## Constant time (O(1))\n+O(1) does not change with respect to input space. Hence, O(1) is referred to as being _constant time_.\n+An exmple of an of an O(1):\n+```javascript\n+function exampleConstantFunc(n) {\n+    return n*n;\n+}\n+```\n+\n+## Linear time (O(n))\n+\n+O(n) is *linear* time and applies to algorithms that must do *n* operations in the worst-case scenario.\n+most its just A simple basic loop that within it we perform constant time operations.\n+An exmple of an of an O(1):\n+```javascript\n+function exampleLinear(n) {\n+    for (var i = 0 ; i < n; i++ ) {\n+        console.log(i)\n+    }\n+}\n+```\n+\n+## Logarithmic time O(log(n))\n+\n+A Logarithmic time function is one in which the time of execution is proportional to the logarithm of the input size. \n+Consider the following example:\n+```javascript\n+function log(n) {\n+    for (let i = 1; i > n; i*=2) {\n+        const result = i;\n+        console.log(result);  \n+    }\n+}\n+```\n+\n+We can see that in any given iteration, the value of i = 2i, so in the nth iteration, the value of i= 2n. Also, we know that the value of i is always less than the size of the loop itself (N). \n+From that, we can deduce the following result:\n+2[^n] < N\n+log(2[^n]) < log(N)\n+n < log(N)\n+\n+From the preceding code, we can see that the number of iterations would always be less than the log on the input size. Hence, the worst-case time complexity of such an algorithm would be O(log(n)).\n+The efficiency of logarithmic time complexities is apparent with large inputs such as a million items.\n+\n+## Quadratic time(O(n^2))\n+\n+With quadratic time algorithms, we have now entered the dark side of the time complexity.\n+As the name suggests, the size of the input quadratically affects the running time of the algorithm. One common example is nested loops:\n+\n+```javascript\n+for (int i = 0; i <n; i += c) {\n+    for (int j = 0; j < n; j += c) {\n+    // some O(1) expressions\n+    }\n+}\n+```\n+\n+As you can see from the preceding example, for i = 0, the inner loop runs n times, and the same for i = 1, and i = 2, and so on. The inner loop always runs n times and is not dependent on the value of n, thus making the algorithms time complexity O(n<sup>2</sup>).\n+\n+## Polynomial time(O(n<sup>n</sup>))\n+\n+Polynomial time complexity is the running time complexity of algorithms, which runs to the order of n<sup>k</sup>. Quadratic time algorithms are certain types of polynomial time algorithms where k = 2. A very simple example of such an algorithm would be as follows:\n+\n+```javascript\n+\n+for (int i = 0; i <n; i += c) {\n+    for (int j = 0; j < n; j += c) {\n+        for (int k = 0; k < n; k += c) {\n+            // some O(1) expressions\n+        }\n+    }\n+}\n+\n+```\n+As you can see, this example is just an extension of the example in the quadratic time section. The worst case complexity of this case is O(n<sup>3</sup>).\n+As you can see, this example is just an extension of the example in the quadratic time\n+section. The worst case complexity of this case is O(n<sup>3</sup>).\n+\n+## Rules of Big-O Notation\n+\n+Let’s represent an algorithm’s complexity as f(n). n represents the number of inputs, f(n)time represents the time needed, and f(n)space represents the space (additional memory) needed for the algorithm. The goal of algorithm analysis is to understand the algorithm’s efficiency by calculating f(n).\n+However, it can be challenging to calculate f(n). Big-O notation provides some fundamental rules that help developers compute for f(n).\n+\n+### Coefficient Rule: “Get Rid of Constants”\n+\n+Let’s first review the coefficient rule. This rule is the easiest rule to understand. It simply requires you to ignore any non-input-size-related constants. Coefficients in Big-O are negligible with large input sizes. Therefore, this is the most important rule of Big-O notations.\n+> If f(n) is O(g(n)), then kf(n) is O(g(n)), for any constant k > 0.\n+\n+This means that both 5f(n) and f(n) have the same Big-O notation of O(f(n)).\n+Here is an example of a code block with a time complexity of O(n):\n+\n+```javascript\n+function a(n){\n+    var count =0;\n+    for (var i=0;i<n;i++){\n+        count+=1;\n+    }\n+    return count;\n+}\n+```\n+> This block of code has f(n) = n. This is because it adds to count n times. Therefore, this function is O(n) in time complexity:\n+```javascript\n+function a(n){\n+    var count =0;\n+    for (var i=0;i<5*n;i++){\n+        count+=1;\n+    }\n+    return count;\n+}\n+```\n+\n+This block has f(n) = 5n. This is because it runs from 0 to 5n.\n+However, the first two examples both have a Big-O notation of O(n). Simply put, this is because if n is close to infinity or another large number, those four additional operations are meaningless. \n+It is going to perform it n times. Any constants are negligible in Big-O notation.\n+\n+### Sum Rule: “Add Big-Os Up”\n+\n+The sum rule is intuitive to understand; time complexities can be added. Imagine a master algorithm that involves two other algorithms. The Big-O notation of that master algorithm is simply the sum of the other two Big-O notations.\n+> If f(n) is O(h(n)) and g(n) is O(p(n)), then f(n)+g(n) is O(h(n)+p(n)).\n+\n+It is important to remember to apply the coefficient rule after applying this rule.\n+The following code block demonstrates a function with two main loops whose time complexities must be considered independently and then summed:\n+\n+```javascript\n+function a(n){\n+    var count =0;\n+    for (var i=0; i<n; i++){\n+        count+=1;\n+    }\n+    for (var i=0; i<5*n; i++){\n+        count+=1;\n+    }\n+    return count;\n+}\n+```\n+\n+In this example, line 4 has f(n) = n, and line 7 has f(n) = 5n. This results in 6n.\n+However, when applying the coefficient rule, the final result is O(n) = n.\n+\n+### Product Rule: “Multiply Big-Os”\n+\n+The product rule simply states how Big-Os can be multiplied.\n+> If f(n) is O(h(n)) and g(n) is O(p(n)), then f(n)g(n) is O(h(n)p(n)).\n+The following code block demonstrates a function with two nested for loops for which the product rule is applied:\n+\n+```javascript\n+function (n){\n+    var count =0;\n+    for (var i=0; i<n; i++){\n+        count+=1;\n+        for (var i=0; i<5*n; i++){\n+            count+=1;\n+        }\n+    }\n+    return count;\n+}\n+```\n+\n+In this example, f(n) = 5n*n because line 7 runs 5n times for a total of n iterations.\n+Therefore, this results in a total of 5n<sup>2</sup> operations. Applying the coefficient rule, the result is that O(n)=n<sup>2</sup>\n+\n+### Polynomial Rule: “Big-O to the Power of k”\n+\n+The polynomial rule states that polynomial time complexities have a Big-O notation of the same polynomial degree.\n+Mathematically, it’s as follows:\n+> If f(n) is a polynomial of degree k, then f(n) is O(n<sup>k</sup>).\n+The following code block has only one for loop with quadratic time complexity:\n+```javascript\n+function a(n){\n+\n+    var count =0;\n+\n+    for (var i=0; i<n*n; i++){\n+        count+=1;\n+    }\n+    return count;\n+}\n+```\n+\n+In this example, f(n) = n<sup>2</sup> because line 4 runs n*n iterations.\n+\n+## Polynomial time complexity classes\n+\n+Now that we have started this conversation, most of the time complexity types that we have discussed here so far are of the O(n<sup>k</sup>) type, for example, it is a constant time complexity for n = 1, whereas it is quadratic complexity for k = 2.\n+The concept of polynomial time complexity leads us into a class of problems, which are defined based on the complexity of their solutions. The following are the types of classes:\n+* P: Any problem that can be solved in polynomial time O(n<sup>k</sup>).\n+* NP: Any problem that can be verified in polynomial time. There can exist problems (such as sudoku solving) that can be solved in non-deterministic polynomial time. If the solution to these problems can be verified in polynomial time, then the problem is classified as an NP-class problem. NP-class problems are a superset of the P-class problems.\n+* NP-Complete: Any NP problem that can be reduced as a function of another NP problem in polynomial time can be classified as an NP-Complete problem. This means that if we know the solution to a certain NP problem, then a solution to another NP problem can be derived in polynomial time.\n+* NP-Hard: A problem can be classified as an NP-Hard problem (H) if there exists an NP-Complete problem (C) that can be reduced to H in polynomial time.\n+\n+> In a majority of the real-world scenarios, we will encounter a lot of P and NP problems, a classic example of NP-class problem is Traveling Salesman, where a salesman wants to visit n number of cities to start and end his trip from his house. With a limited amount of gasoline and an upper limit on the total miles that can be driven, can the salesman visit all the cities without running out of gas?\n+\n+## Recursion and additive complexity\n+\n+Until now, we have seen some examples that are pretty straightforward: they all have a single loop or nested loops. However, a lot of times, there will be scenarios in which we will have to handle multiple loops/function calls/branches originating from the same algorithm.\n+Let us see an example of how we can calculate the complexity in that case?\n+\n+1. When we have subsequent loops/function calls, we will need to calculate the individual complexity of each step and then add them to get the overall complexity, as follows:\n+```javascript\n+ function xyz() {\n+    abc(); // O(n) operation\n+    pqr(); // O(log(n)) operation\n+ }\n+ ```\n+\n+The collective complexity of this code would be the summation of the complexity of both the sections. So, in this case, the overall complexity would be O(n + log n), which asymptotically will be O(n).\n+\n+2. When we have branches in our function with varying time complexity, depending on what type of runtime complexity we are talking about, we will need to pick the correct choice:\n+```javascript\n+ function xyz() {\n+    if (someCondition) {\n+        abc(); // O(n) operation\n+    } else {\n+        pqr(); // O(log(n)) operation\n+    }\n+ }\n+ ```\n+In this case, the worst case complexity will be decided by whatever is worst of the two branches, which would be O(n), but the best case complexity would be O(log(n)).\n+\n+3. Recursive algorithms are a little tricky compared to their non-recursive counterparts, since not only do we need to determine what the complexity of our algorithm is, we also need to keep in mind how many times recursion would get triggered because that would contribute toward the overall complexity of the algorithm as shown in the following code snippet:\n+```javascript\n+ function rec1(array) {\n+    // O(1) operations\n+    if (array.length === 0) return;\n+    array.pop();\n+    return rec1(array);\n+ }\n+ ```\n+\n+Although our method only performs some O(1) operations, it constantly changes the input and calls itself until the size of the input array is zero. So, our method ends up executing n times, making the overall time complexity of O(n).'}",[]
78,425,open,,1,['src/algorithms/search/binary-search/BinarySearch.js'],1,['Adding  Binary Search'],"{'Name': 'src/algorithms/search/binary-search/BinarySearch.js', 'Line Additions': 27, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,27 @@\n+var myList = [1, 3, 5, 7, 9];\n+\n+function binarySearch(myList, itemToFind) {\n+\tvar low = 0,\n+        high = myList.length - 1,\n+        mid,\n+        guessed;\n+\n+\twhile(low <= high) {\n+\t    mid = Math.floor((low + high) / 2),\n+\t    guessed = myList[mid];\n+\n+\t    if(guessed === itemToFind) {\n+                console.log('Found item at index: ' + mid + ', value is ' + guessed);\n+\t\t    return;\n+\t    }\n+\t    if(itemToFind < guessed) {\n+\t        high = mid - 1;\n+            } else {\n+\t        low = mid + 1;\n+\t    }\n+        }\n+\n+\treturn null;\n+}\n+\n+binarySearch(myList, 3);""}",[]
79,426,open,,1,['README.md'],1,['Changed wording for clarity in README.md'],"{'Name': 'README.md', 'Line Additions': 3, 'Line Deletions': 3, 'Patch': ""@@ -25,7 +25,7 @@ only and it is **not** meant to be used for production.*\n \n ## Data Structures\n \n-A data structure is a particular way of organizing and storing data in a computer so that it can\n+A data structure is a way of organizing and storing data in a computer so that the data can\n be accessed and modified efficiently. More precisely, a data structure is a collection of data\n values, the relationships among them, and the functions or operations that can be applied to\n the data.\n@@ -147,7 +147,7 @@ a set of rules that precisely define a sequence of operations.\n \n ### Algorithms by Paradigm\n \n-An algorithmic paradigm is a generic method or approach which underlies the design of a class\n+An algorithmic paradigm is a generic method which underlies the design of a class\n of algorithms. It is an abstraction higher than the notion of an algorithm, just as an\n algorithm is an abstraction higher than a computer program.\n \n@@ -255,7 +255,7 @@ npm test -- 'playground'\n ### Big O Notation\n \n *Big O notation* is used to classify algorithms according to how their running time or space requirements grow as the input size grows.\n-On the chart below you may find most common orders of growth of algorithms specified in Big O notation.\n+On the chart below the most common orders of growth of algorithms are specified in Big O notation.\n \n ![Big O graphs](./assets/big-o-graph.png)\n ""}",[]
80,430,open,Modified the definition of BFS for readability. Hope this helps!,1,['src/algorithms/graph/breadth-first-search/README.md'],1,['Update README.md'],"{'Name': 'src/algorithms/graph/breadth-first-search/README.md', 'Line Additions': 1, 'Line Deletions': 5, 'Patch': ""@@ -1,10 +1,6 @@\n # Breadth-First Search (BFS)\n \n-Breadth-first search (BFS) is an algorithm for traversing \n-or searching tree or graph data structures. It starts at\n-the tree root (or some arbitrary node of a graph, sometimes \n-referred to as a 'search key') and explores the neighbor\n-nodes first, before moving to the next level neighbors.\n+Breadth-first search (BFS) is an algorithm for traversing graph data structures. It starts at the tree root or some arbitrary node of a graph, sometimes referred to as a 'search key'. The search then explores the neighbor nodes first before moving to the neighbors of neighbouring nodes.\n \n ![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)\n ""}",[]
81,431,open,Modified the definition of BFS for readability. Hope it helps!,1,['src/algorithms/graph/depth-first-search/README.md'],1,['Update README.md'],"{'Name': 'src/algorithms/graph/depth-first-search/README.md', 'Line Additions': 1, 'Line Deletions': 5, 'Patch': '@@ -1,10 +1,6 @@\n # Depth-First Search (DFS)\n \n-Depth-first search (DFS) is an algorithm for traversing or \n-searching tree or graph data structures. One starts at \n-the root (selecting some arbitrary node as the root in \n-the case of a graph) and explores as far as possible \n-along each branch before backtracking.\n+Depth-first search (DFS) is an algorithm for traversing graph data structures. The search starts at the tree root or some arbitrary node of a graph. The search explores a branch of nodes until reaching a terminal node before backtracking to explore another branch of nodes.\n \n ![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)\n '}",[]
82,435,open,Resolves issue #234 ,3,"['src/algorithms/sorting/bogo-sort/BogoSort.js', 'src/algorithms/sorting/bogo-sort/README.md', 'src/algorithms/sorting/bogo-sort/__test__/BogoSort.test.js']",1,['Add BogoSort'],"{'Name': 'src/algorithms/sorting/bogo-sort/__test__/BogoSort.test.js', 'Line Additions': 59, 'Line Deletions': 0, 'Patch': ""@@ -0,0 +1,59 @@\n+import BogoSort from '../BogoSort';\n+import {\n+  equalArr,\n+  notSortedArr,\n+  reverseArr,\n+  sortedArr,\n+  SortTester,\n+} from '../../SortTester';\n+\n+const SORTED_ARRAY_VISITING_COUNT = 40;\n+const NOT_SORTED_ARRAY_VISITING_COUNT = 40;\n+const REVERSE_SORTED_ARRAY_VISITING_COUNT = 40;\n+const EQUAL_ARRAY_VISITING_COUNT = 40;\n+\n+describe('BogoSort', () => {\n+  it('should sort array', () => {\n+    SortTester.testSort(BogoSort);\n+  });\n+\n+  it('should sort array with custom comparator', () => {\n+    SortTester.testSortWithCustomComparator(BogoSort);\n+  });\n+\n+  it('should sort negative numbers', () => {\n+    SortTester.testNegativeNumbersSort(BogoSort);\n+  });\n+\n+  it('should visit EQUAL array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BogoSort,\n+      equalArr,\n+      EQUAL_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BogoSort,\n+      sortedArr,\n+      SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit NOT SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BogoSort,\n+      notSortedArr,\n+      NOT_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+\n+  it('should visit REVERSE SORTED array element specified number of times', () => {\n+    SortTester.testAlgorithmTimeComplexity(\n+      BogoSort,\n+      reverseArr,\n+      REVERSE_SORTED_ARRAY_VISITING_COUNT,\n+    );\n+  });\n+});""}",[]
83,438,open,"* Allow graph edges with custom keys. This is important if we have two edges connected to the same vertices but having a different weight. We could have used the weight in the name, but as conceptually two edges could also have the same vertices and weight, I think it's a better idea to propose the user a way to make sure this edge case (pun intended) doesn't happen.
* Vertex can be converted to string, so I made sure that the `toString()` method is called, in case we have objects convertible to strings. The native `toString()` implementation might throw exceptions as expected.
* Edge key is now sure to be correctly converted to string too.
* We currently can't add an edge twice to a graph, I also added support for not adding a vertex twice.",6,"['src/data-structures/graph/Graph.js', 'src/data-structures/graph/GraphEdge.js', 'src/data-structures/graph/GraphVertex.js', 'src/data-structures/graph/__test__/Graph.test.js', 'src/data-structures/graph/__test__/GraphEdge.test.js', 'src/data-structures/graph/__test__/GraphVertex.test.js']",4,"['Allow graph edges with custom keys', 'Make sure graph vertex value is converted to string', 'Make sure toString is called on edge key when calling edge.toString()', ""Make sure a vertex can't be added twice to a graph""]","{'Name': 'src/data-structures/graph/__test__/GraphVertex.test.js', 'Line Additions': 16, 'Line Deletions': 0, 'Patch': ""@@ -185,4 +185,20 @@ describe('GraphVertex', () => {\n \n     expect(vertexA.getEdges().length).toEqual(3);\n   });\n+\n+  it('should execute callback when passed to toString', () => {\n+    const vertex = new GraphVertex('A');\n+\n+    expect(vertex.toString(() => 'B')).toEqual('B');\n+  });\n+\n+  it('should execute toString on value when calling toString on vertex', () => {\n+    const value = {\n+      toString() { return 'A'; },\n+    };\n+\n+    const vertex = new GraphVertex(value);\n+\n+    expect(vertex.toString()).toEqual('A');\n+  });\n });""}",[]
84,446,open,Add a test to the LinkedList structure to test the toArray() method,1,['src/data-structures/linked-list/__test__/LinkedList.test.js'],2,"['Update LinkedList.test.js\n\nAdd a test to the LinkedList structure to test the toArray() method', 'Update LinkedList.test.js\n\nRemove only alias']","{'Name': 'src/data-structures/linked-list/__test__/LinkedList.test.js', 'Line Additions': 18, 'Line Deletions': 0, 'Patch': ""@@ -1,4 +1,5 @@\n import LinkedList from '../LinkedList';\n+import LinkedListNode from '../LinkedListNode';\n \n describe('LinkedList', () => {\n   it('should create empty linked list', () => {\n@@ -192,6 +193,23 @@ describe('LinkedList', () => {\n     expect(linkedList.toString()).toBe('1,1,2,3,3,3,4,5');\n   });\n \n+  it('should return a linked list node array', () => {\n+    const linkedList = new LinkedList();\n+\n+    expect(linkedList.head).toBeNull();\n+    expect(linkedList.tail).toBeNull();\n+\n+    linkedList.append(1);\n+    linkedList.append(2);\n+\n+    expect(linkedList.toArray().length).toBe(2);\n+\n+    const linkedListNode2 = new LinkedListNode(2);\n+    const linkedListNode1 = new LinkedListNode(1, linkedListNode2);\n+\n+    expect(linkedList.toArray()).toEqual([linkedListNode1, linkedListNode2]);\n+  });\n+\n   it('should find node by means of custom compare function', () => {\n     const comparatorFunction = (a, b) => {\n       if (a.customValue === b.customValue) {""}","[""You've forgotten to remove `.only`."", 'Done.']"
85,452,open,Adding an example of a binary search in JavaScript video,1,['src/algorithms/search/binary-search/README.md'],1,['Update README.md\n\nAdding an example of a binary search in JavaScript video'],"{'Name': 'src/algorithms/search/binary-search/README.md', 'Line Additions': 1, 'Line Deletions': 0, 'Patch': '@@ -21,3 +21,4 @@ next iteration.\n \n - [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n - [YouTube](https://www.youtube.com/watch?v=P3YID7liBug&index=29&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n+- [YouTube - JavaScript](https://youtu.be/7lGiPItOVCM)'}",[]
86,456,open,,1,['src/algorithms/string/levenshtein-distance/levenshteinDistance.js'],1,['Update levenshteinDistance.js'],"{'Name': 'src/algorithms/string/levenshtein-distance/levenshteinDistance.js', 'Line Additions': 17, 'Line Deletions': 0, 'Patch': '@@ -35,3 +35,20 @@ export default function levenshteinDistance(a, b) {\n \n   return distanceMatrix[b.length][a.length];\n }\n+\n+export function levenshteinDistanceRec(P, T, i, j) {\n+    // if called without initial distances, start with the length of the strings\n+    if (i === undefined || j === undefined) return levenshteinDistanceRec(P, T, P.length - 1, T.length - 1);\n+  \n+    // establish base cases\n+    if (i === 0 && j === 0) return 0;\n+    if (i === 0) return j;\n+    if (j === 0) return i;\n+\n+    var sub = levenshteinDistanceRec(P, T, i-1, j-1) + (P[i]===T[j] ? 0 : 1); // substitution\n+    var del = levenshteinDistanceRec(P, T, i, j-1) + 1; // insertion\n+    var add = levenshteinDistanceRec(P, T, i-1, j) + 1; // deletion\n+    \n+    // pick the transformation that minimizes the distance\n+    return Math.min(sub, add, del);\n+};'}",[]
87,458,open,"My changes should fix #308.

I have refactored combinationSum to use an iterative approach to avoid stack overflows when the decision tree gets too deep (candidates=[1], target=100000).

Additionally, the code now filters out any candidate equal to zero to avoid loops.",3,"['src/algorithms/sets/combination-sum/README.md', 'src/algorithms/sets/combination-sum/__test__/combinationSum.test.js', 'src/algorithms/sets/combination-sum/combinationSum.js']",3,"['Refactor combinationSum to an iterative algo\n\n- Refactor combinationSum to use an iterative algorithm (to avoid stack overflows).\r\n- Ignore candidates equal to zero (to avoid loops).', 'Add test cases mentioned in #308', 'Update combinationSum README to reflect new implementation']","{'Name': 'src/algorithms/sets/combination-sum/combinationSum.js', 'Line Additions': 43, 'Line Deletions': 57, 'Patch': ""@@ -1,65 +1,51 @@\n /**\n- * @param {number[]} candidates - candidate numbers we're picking from.\n- * @param {number} remainingSum - remaining sum after adding candidates to currentCombination.\n- * @param {number[][]} finalCombinations - resulting list of combinations.\n- * @param {number[]} currentCombination - currently explored candidates.\n- * @param {number} startFrom - index of the candidate to start further exploration from.\n- * @return {number[][]}\n- */\n-function combinationSumRecursive(\n-  candidates,\n-  remainingSum,\n-  finalCombinations = [],\n-  currentCombination = [],\n-  startFrom = 0,\n-) {\n-  if (remainingSum < 0) {\n-    // By adding another candidate we've gone below zero.\n-    // This would mean that the last candidate was not acceptable.\n-    return finalCombinations;\n-  }\n-\n-  if (remainingSum === 0) {\n-    // If after adding the previous candidate our remaining sum\n-    // became zero - we need to save the current combination since it is one\n-    // of the answers we're looking for.\n-    finalCombinations.push(currentCombination.slice());\n-\n-    return finalCombinations;\n-  }\n-\n-  // If we haven't reached zero yet let's continue to add all\n-  // possible candidates that are left.\n-  for (let candidateIndex = startFrom; candidateIndex < candidates.length; candidateIndex += 1) {\n-    const currentCandidate = candidates[candidateIndex];\n-\n-    // Let's try to add another candidate.\n-    currentCombination.push(currentCandidate);\n-\n-    // Explore further option with current candidate being added.\n-    combinationSumRecursive(\n-      candidates,\n-      remainingSum - currentCandidate,\n-      finalCombinations,\n-      currentCombination,\n-      candidateIndex,\n-    );\n-\n-    // BACKTRACKING.\n-    // Let's get back, exclude current candidate and try another ones later.\n-    currentCombination.pop();\n-  }\n-\n-  return finalCombinations;\n-}\n-\n-/**\n- * Backtracking algorithm of finding all possible combination for specific sum.\n+ * Iterative algorithm to find all combinations (repetitions allowed)\n+ * that sum up to a given number (target) using elements\n+ * from a set of positive integers (candidates).\n  *\n  * @param {number[]} candidates\n  * @param {number} target\n  * @return {number[][]}\n  */\n export default function combinationSum(candidates, target) {\n-  return combinationSumRecursive(candidates, target);\n+  const combinations = [];\n+\n+  const nonZeroCandidates = Array.from(new Set(candidates.filter(c => c > 0).slice().reverse()));\n+  const stack = nonZeroCandidates\n+    .map((candidate, index) => ({ candidateIndex: index, sum: candidate, prev: null }));\n+\n+  while (stack.length > 0) {\n+    const node = stack.pop();\n+\n+    if (node.sum === target) {\n+      /*\n+      If the cumulative sum matches the target value\n+      then we build the corresponding candidates combination\n+      by traversing the current branch back to its root...\n+      */\n+      const combination = [];\n+      let currentNode = node;\n+      while (currentNode !== null) {\n+        const candidate = nonZeroCandidates[currentNode.candidateIndex];\n+        combination.push(candidate);\n+        currentNode = currentNode.prev;\n+      }\n+      combinations.push(combination);\n+    } else if (node.sum < target) {\n+      /*\n+      ...otherwise we combine the current branch\n+      with any other candidate (as long as it is\n+      less or equal than the current candidate)\n+      and evaluate the new branches.\n+      */\n+      for (let i = node.candidateIndex; i < nonZeroCandidates.length; i += 1) {\n+        stack.push({\n+          candidateIndex: i,\n+          sum: node.sum + nonZeroCandidates[i],\n+          prev: node,\n+        });\n+      }\n+    }\n+  }\n+  return combinations;\n }""}",[]
88,467,open,If its looks good I can submit pull requests for some of the other data structures I think should be iterable.,2,"['src/data-structures/linked-list/LinkedList.js', 'src/data-structures/linked-list/__test__/LinkedList.test.js']",3,"['Make the linked list an iterable', 'tests linked list is iterable', ""Merge branch 'master' into master""]","{'Name': 'src/data-structures/linked-list/__test__/LinkedList.test.js', 'Line Additions': 13, 'Line Deletions': 0, 'Patch': ""@@ -243,4 +243,17 @@ describe('LinkedList', () => {\n     expect(linkedList.head.value).toBe(1);\n     expect(linkedList.tail.value).toBe(3);\n   });\n+  \n+  it('should be iterable', () => {\n+    const linkedList = new LinkedList();\n+    expect(typeof linkedList[Symbol.iterator]).toBe('function');\n+\n+    // Add test values to linked list.\n+    linkedList\n+      .append(1)\n+      .append(2)\n+      .append(3);\n+\n+    expect([...linkedList]).toEqual([1, 2, 3]);\n+  });\n });""}",[]
89,473,open,"**Problem:** All tests have been failed due to ""SecurityError: localStorage is not available for opaque origins""
**Solution:** [Add testUrl](https://github.com/facebook/jest/issues/6769#issuecomment-408352345)",1,['jest.config.js'],1,['Update jest.config.js'],"{'Name': 'jest.config.js', 'Line Additions': 1, 'Line Deletions': 0, 'Patch': '@@ -1,5 +1,6 @@\n module.exports = {\n   verbose: false,\n+  testURL: ""http://localhost/"",\n   collectCoverage: false,\n   coverageDirectory: \'./coverage/\',\n };'}",[]
90,479,open,,3,"['.editorconfig', '.gitattributes', 'src/utils/comparator/Comparator.js']",2,"['fix JSDoc tag', 'add rule for Editorconfig and useful Git attributes']","{'Name': 'src/utils/comparator/Comparator.js', 'Line Additions': 1, 'Line Deletions': 1, 'Patch': '@@ -11,7 +11,7 @@ export default class Comparator {\n    * Default comparison function. It just assumes that ""a"" and ""b"" are strings or numbers.\n    * @param {(string|number)} a\n    * @param {(string|number)} b\n-   * @returns {number}\n+   * @return {number}\n    */\n   static defaultCompareFunction(a, b) {\n     if (a === b) {'}",[]
91,504,open,"Make it consistent with the description:

""It sequentially checks each element of the list for the target value until a match is found or until all the elements have been searched.""",2,"['src/algorithms/search/linear-search/__test__/linearSearch.test.js', 'src/algorithms/search/linear-search/linearSearch.js']",1,['Linear search fix.'],"{'Name': 'src/algorithms/search/linear-search/linearSearch.js', 'Line Additions': 5, 'Line Deletions': 6, 'Patch': ""@@ -10,13 +10,12 @@ import Comparator from '../../../utils/comparator/Comparator';\n  */\n export default function linearSearch(array, seekElement, comparatorCallback) {\n   const comparator = new Comparator(comparatorCallback);\n-  const foundIndices = [];\n \n-  array.forEach((element, index) => {\n-    if (comparator.equal(element, seekElement)) {\n-      foundIndices.push(index);\n+  for (let i = 0; i < array.length; i += 1) {\n+    if (comparator.equal(array[i], seekElement)) {\n+      return i;\n     }\n-  });\n+  }\n \n-  return foundIndices;\n+  return -1;\n }""}",[]
92,523,open,,1,['src/algorithms/math/is-power-of-two/different_power_of2.js'],1,['Create different_power_of2.js'],"{'Name': 'src/algorithms/math/is-power-of-two/different_power_of2.js', 'Line Additions': 19, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,19 @@\n+\n+  // different power of 2 requiered so that the sum of different power of 2 equals to no..\n+export default function diffPowerOfTwo(number) {\n+  if (number < 1) {\n+    return 0;\n+  }\n+  var a=0;\n+  let dividedNumber = number;\n+  while (dividedNumber !== 1) {\n+    if (dividedNumber % 2 !== 0) {\n+      a+=1;\n+    }\n+    a+=1;\n+\n+    dividedNumber /= 2;\n+  }\n+\n+  return a;\n+}'}","['typo here - `requiered` (sic) should be `required`', 'Can you please help me. What is sis why i am getting the error.\r\n', '""Sic"" is meant to indicate that there\'s a typo without fixing it. \r\n\r\nNot sure on the error 😅\r\n\r\nhttps://www.merriam-webster.com/words-at-play/sic-meaning-usage-editorial-citation']"
93,537,open,"Array were initialized with `null` and later first row and column were assigned with value 0.
but it can be initialized directly with 0.",1,['src/algorithms/string/longest-common-substring/longestCommonSubstring.js'],1,['Remove extra init loops in lcs'],"{'Name': 'src/algorithms/string/longest-common-substring/longestCommonSubstring.js', 'Line Additions': 1, 'Line Deletions': 12, 'Patch': '@@ -12,18 +12,7 @@ export default function longestCommonSubstring(string1, string2) {\n   const s2 = [...string2];\n \n   // Init the matrix of all substring lengths to use Dynamic Programming approach.\n-  const substringMatrix = Array(s2.length + 1).fill(null).map(() => {\n-    return Array(s1.length + 1).fill(null);\n-  });\n-\n-  // Fill the first row and first column with zeros to provide initial values.\n-  for (let columnIndex = 0; columnIndex <= s1.length; columnIndex += 1) {\n-    substringMatrix[0][columnIndex] = 0;\n-  }\n-\n-  for (let rowIndex = 0; rowIndex <= s2.length; rowIndex += 1) {\n-    substringMatrix[rowIndex][0] = 0;\n-  }\n+  const substringMatrix = Array(s2.length + 1).fill(0).map(() => Array(s1.length + 1).fill(0));\n \n   // Build the matrix of all substring lengths to use Dynamic Programming approach.\n   let longestSubstringLength = 0;'}",[]
94,545,open,,3,"['.huskyrc.json', 'src/data-structures/priority-queue/__test__/PriorityQueue.test.js', 'src/data-structures/priority-queue/new-priorety-queue.js']",2,"['finish', ""Merge branch 'master' into master""]","{'Name': 'src/data-structures/priority-queue/new-priorety-queue.js', 'Line Additions': 60, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,60 @@\n+\n+export default class PriorityQueue {\n+    constructor() {\n+      this.arr=[];\n+    }\n+    isEmpty(){\n+        return this.arr.length===0;\n+    }\n+    peek(){\n+      return  this.isEmpty() ? null : this.arr[this.arr.length - 1][0];\n+    }\n+    add(item , priority = 0){\n+          if(this.isEmpty()){\n+             return this.arr =[[item,priority]];\n+          }\n+          for( let i = 0; i < this.arr.length; i++ ){\n+              if(this.arr[i][1] <= priority ){\n+                  this.arr.splice(i,0,[item,priority]);\n+                  return this.arr;\n+              }\n+          }\n+          return this.arr.push([item,priority]);\n+    }\n+  \n+    poll(){\n+        if(this.isEmpty()){\n+            return null;\n+        }\n+        return this.arr.pop()[0];\n+    }\n+\n+    changePriority(item, priority = 0) {\n+        if(this.isEmpty()) {\n+          return null;\n+        }\n+        for (let i = 0; i < this.arr.length; i++) {\n+          if (this.arr[i][0] === item) {\n+            this.arr.splice(i, 1);\n+            this.add(item, priority);\n+            return this.arr;\n+          }\n+        }\n+        return null;\n+      }\n+    \n+      hasValue(item) {\n+        if(this.isEmpty()) {\n+          return false;\n+        }\n+        for (let i = 0; i < this.arr.length; i++) {\n+          if (this.arr[i][0] === item) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+  }\n+  \n+\n+  \n\\ No newline at end of file'}",[]
95,554,open,Added Solution to #550 Add A Star Algorithm.,2,"['src/algorithms/search/a-star searching/A Star Searching Algorithm.js', 'src/algorithms/search/a-star searching/README.md']",3,"[' a * search algorithm added', 'Sorting Visualizer added', '.']","{'Name': 'src/algorithms/search/a-star searching/README.md', 'Line Additions': 27, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,27 @@\n+This is the actual implementation of the algorithm. I will do my best to explain what is going on, but feel free to just look at the source of the example, or just download astar.js.\n+\n+There are three functions that we keep track of for nodes that we look at:\n+\n+g(x): The total cost of getting to that node (pretty straightforward). If we reach a node for the first time or reach a node in less time than it currently took, then update the g(x) to the cost to reach this node.\n+h(x): The estimated time to reach the finish from the current node. This is also called a heuristic. We online need to update this if it is not set already, since the distance to the finish will not change even if the path we took to arrive at a node changes. Note: There are many different ways to guess how far you are from the end, I use the Manhattan distance in this implementation.\n+f(x): Simply g(x) + h(x). The lower the f(x), the better. Think about it like this: the best node is one that takes the least total amount of time to arrive at and to get to the end. So, a node that took only 1 step to arrive at and 5 to get to the end is more ideal than one that took 10 to arrive and and only 1 to get to the end.\n+\n+\n+\n+\n+\n+PsuedoCode:\n+push startNode onto openList\n+while(openList is not empty) {\n+ currentNode = find lowest f in openList\n+ if currentNode is final, return the successful path\n+ push currentNode onto closedList and remove from openList\n+ foreach neighbor of currentNode {\n+     if neighbor is not in openList {\n+            save g, h, and f then save the current parent\n+            add neighbor to openList\n+     }\n+     if neighbor is in openList but the current g is better than previous g {\n+             save g and f, then save the current parent\n+     }\n+ }\n\\ No newline at end of file'}",[]
96,556,open,,1,['src/algorithms/math/armstrong.js'],2,"['Armstrong Number added', ""Merge branch 'master' into hk""]","{'Name': 'src/algorithms/math/armstrong.js', 'Line Additions': 22, 'Line Deletions': 0, 'Patch': '@@ -0,0 +1,22 @@\n+// Check Armstrong Number of n Digits\n+\n+let number = prompt(""Enter a positive integer"");\n+let numberOfDigits = number.length;\n+let sum = 0;\n+\n+let temp = number;\n+\n+while (temp > 0) {\n+\n+    let remainder = temp % 10;\n+\n+    sum += remainder ** numberOfDigits;\n+\n+    temp = parseInt(temp / 10); \n+\n+if (sum == number) {\n+    console.log(`${number} is an Armstrong number`);\n+}\n+else {\n+    console.log(`${number} is not an Armstrong number.`);\n+}\n\\ No newline at end of file'}",[]
97,559,open,,1,['src/data-structures/linked-list/LinkedList.js'],1,['Add function to insert a node at a given index in a linked list'],"{'Name': 'src/data-structures/linked-list/LinkedList.js', 'Line Additions': 53, 'Line Deletions': 0, 'Patch': ""@@ -54,6 +54,59 @@ export default class LinkedList {\n     return this;\n   }\n \n+  /**\n+   * @param {*} value\n+   * @param {*} index\n+   * @return {LinkedList}\n+   */\n+  insert(value,index) {\n+    // index needs to be positive\n+    if (index < 0) {\n+      return this;\n+    }\n+\n+    // If linked list is empty...\n+    if (!this.head) {\n+      this.head = newNode;\n+      this.tail = newNode;\n+      return this;\n+    }\n+\n+    if (index === 0) {\n+      // Make new node to be a head.\n+      const newNode = new LinkedListNode(value, this.head);\n+      this.head = newNode;\n+\n+      // If there is no tail yet let's make new node a tail.\n+      if (!this.tail) {\n+        this.tail = newNode;\n+      }\n+\n+      return this;\n+    }\n+\n+    // If there are many nodes in linked list...\n+\n+    // Rewind to the node before required index then link it to new node\n+    // and link the new node to next node\n+    const newNode = new LinkedListNode(value);\n+    let i = 0;\n+    let currentNode = this.head;\n+    while (i < index - 1 && currentNode.next) {\n+      currentNode = currentNode.next;\n+      i++;\n+    }\n+    // If index > length let's make new node a tail.\n+    if (!currentNode.next) {\n+      currentNode.next = newNode;\n+      this.tail = newNode;\n+      return this;\n+    }\n+    newNode.next = currentNode.next;\n+    currentNode.next = newNode;\n+    return this;\n+  }\n+\n   /**\n    * @param {*} value\n    * @return {LinkedListNode}""}",[]
98,561,open,"leftRightRotation and rightLeftRotation didn't work correctly, so I had some sudden errors afterwards. I found the problem and wrote fixes, tests and comments.
You can better understand what the problem is on this picture (leftRightRotation): ![leftRightRotation](https://user-images.githubusercontent.com/61697000/95685552-36debe00-0c01-11eb-808a-79673f3c5c28.png).
For rightLeftRotation it is similar.

Thank you a lot for this cool repo :)",2,"['src/data-structures/tree/red-black-tree/RedBlackTree.js', 'src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js']",1,"['fix 2 functions of RedBlackTree, write tests']","{'Name': 'src/data-structures/tree/red-black-tree/__test__/RedBlackTree.test.js', 'Line Additions': 43, 'Line Deletions': 0, 'Patch': ""@@ -321,4 +321,47 @@ describe('RedBlackTree', () => {\n \n     expect(removeNodeFromRedBlackTree).toThrowError();\n   });\n+\n+  it('should set parent of parent node correctly in first part of leftRightRotation', () => {\n+    const tree = new RedBlackTree();\n+\n+    tree.insert(15);\n+    tree.insert(100);\n+    tree.insert(7);\n+    const node1 = tree.insert(1);\n+    // now 15 is root, 7 is his left child, 100 is right, 1 is left child of 7\n+    const node5 = tree.insert(5);\n+    // rotation: at first, 7 is Grandparent, 1 is his left child and Parent of his right Child 5\n+    // . 7\n+    // 1\n+    // . 5\n+    // after rotation 5 is parent of 1 and 7, 1 is left child, 7 is right child\n+    // . 5\n+    // 1 . 7\n+    // so, 5.left = 1 and 1.parent = 5 (should be)\n+    expect(node5.left).toBe(node1);\n+    expect(node1.parent).toBe(node5);\n+  });\n+\n+  it('should set parent of parent node correctly in first part of rightLeftRotation', () => {\n+    const tree = new RedBlackTree();\n+\n+    tree.insert(15);\n+    tree.insert(100);\n+    tree.insert(7);\n+    const node120 = tree.insert(120);\n+    // now 15 is root, 7 is his left child, 100 is right, 120 is right child of 100\n+    const node110 = tree.insert(110);\n+    // rotation: at first, 100 is Grandparent,\n+    // 120 is his right child and Parent of his left Child 110\n+    // 100\n+    // . 120\n+    // 110\n+    // after rotation 110 is parent of 100 and 120, 100 is left child, 120 is right child\n+    // .. 110\n+    // 100 . 120\n+    // so, 110.right = 120 and 120.parent = 110 (should be)\n+    expect(node110.right).toBe(node120);\n+    expect(node120.parent).toBe(node110);\n+  });\n });""}",[]
99,565,open,Closes #564 ,8,"['README.md', 'src/algorithms/math/mini-max/MiniMax.js', 'src/algorithms/math/mini-max/Readme.md', 'src/algorithms/math/mini-max/__test__/miniMax.test.js', 'src/algorithms/search/linear-search/__test__/linearSearch.test.js', 'src/algorithms/search/linear-search/linearSearch.js', 'src/algorithms/sorting/insertion-sort/InsertionSort.js', 'src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js']",4,"['Typo Fix in BFS test', 'Added Mini-Max sum Algorithm', 'Remove Array check and optimise', 'Added Linear Search Fix']","{'Name': 'src/algorithms/tree/breadth-first-search/__test__/breadthFirstSearch.test.js', 'Line Additions': 1, 'Line Deletions': 1, 'Patch': ""@@ -2,7 +2,7 @@ import BinaryTreeNode from '../../../../data-structures/tree/BinaryTreeNode';\n import breadthFirstSearch from '../breadthFirstSearch';\n \n describe('breadthFirstSearch', () => {\n-  it('should perform DFS operation on tree', () => {\n+  it('should perform BFS operation on tree', () => {\n     const nodeA = new BinaryTreeNode('A');\n     const nodeB = new BinaryTreeNode('B');\n     const nodeC = new BinaryTreeNode('C');""}",[]
100,589,open,"I have added one file to your repository, this file contains a function which take a number and returns the power of two which is directly greater than the given number. I have also added a test file and a README file.",6,"['package-lock.json', 'src/algorithms/math/power-of-two-greater-than-number/README.md', 'src/algorithms/math/power-of-two-greater-than-number/__test__/powerOfTwoGreaterThanNumber.test.js', 'src/algorithms/math/power-of-two-greater-than-number/powerOfTwoGreaterThanNumber.js', 'src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js', 'src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js']",7,"['definition of the function which determines the power of 2 which directly follows a given number', ""Merge branch 'master' of https://github.com/trekhleb/javascript-algorithms"", 'Add README in english', ""Merge branch 'master' into master"", ""Merge branch 'master' of https://github.com/trekhleb/javascript-algorithms"", 'adding a method to get the successor of a node inside the birany search tree data structure', 'using the built in comparator of BinarySearchTreeNode class to compare some value inside the function successor for getting the successor of a node']","{'Name': 'src/data-structures/tree/binary-search-tree/__test__/BinarySearchTreeNode.test.js', 'Line Additions': 17, 'Line Deletions': 0, 'Patch': ""@@ -252,4 +252,21 @@ describe('BinarySearchTreeNode', () => {\n \n     expect(childNode.parent).toBeNull();\n   });\n+\n+  it('should get the successor of a node', () => {\n+    const rootNode = new BinarySearchTreeNode(5);\n+    rootNode.insert(2);\n+    rootNode.insert(3);\n+    rootNode.insert(1);\n+    rootNode.insert(7);\n+    rootNode.insert(6);\n+\n+    const node = rootNode.find(1);\n+    const node2 = rootNode.find(6);\n+    const node3 = rootNode.find(7);\n+\n+    expect(node.successor().value).toBe(2);\n+    expect(node2.successor().value).toBe(7);\n+    expect(node3.successor()).toBeNull();\n+  });\n });""}",[]
